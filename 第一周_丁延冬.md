# 第一周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|        |   3    |        |

## II 本周刷题总结

### 第1题 [省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

难度：中等

方法：dfs/bfs/并查集

#### a. 原题陈述

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

#### b. 解题思路

定义问题：无向图的连通域判断；

bfs/dfs + visited布尔数组

并查集--认父亲

#### c. 解题代码

dfs

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int res = 0;
        for(int i = 0; i < n; ++i){
            if(!visited[i]){// 城市尚未访问，则进入访问
                res++;// 即使没有和任何其他城市相连，也计数1
                dfs(i,isConnected,visited);// i城市与其他城市的连接情况
            }
        }
        return res;
    }
    private void dfs(int i, int[][] isConnected, boolean[] visited){
        visited[i] = true;// 将访问过的城市置1
        for(int j = 0; j < isConnected.length; ++j){
            if(isConnected[i][j] == 1 && !visited[j]){
                dfs(j, isConnected, visited);
            }
        }
    }
}
```

#### d. 其他解法摘录

并查集

[并查集题目](https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/)

[并查集时间复杂度](https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/)

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        UnionFind ur = new UnionFind(n);// 初始化
        for(int i = 0; i < n; ++i){
            for(int j = i+1; j < n; ++j){
                if(isConnected[i][j] == 1){
                    ur.union(i,j);
                }
            }
        }
        return ur.size;
        
    }
}

class UnionFind{
    int[] roots;
    int size;
    public UnionFind(int n){// 构造函数
        roots = new int[n];// roots初始化
        for(int i = 0; i < n; ++i){
            roots[i] = i;
        }
        size = n;
    }
    public int find(int i){
        if(i == roots[i]){
            return i;
        }
        return roots[i] = find(roots[i]);// 找到最深的父节点
    }
    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot != qRoot){
            roots[pRoot] = qRoot;
            size--;// 合并时size--
        }
    }
}
```

------

### 第2题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

