# 第一周_陈明虓

## 

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

#### 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

#### b. 解题思路

#### 递归

#### c. 解题代码

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            List<TreeNode> plist = new ArrayList<>();
            List<TreeNode> qlist = new ArrayList<>();
            fuction(root, p, plist);
            fuction(root, q, qlist);
            int sizep = plist.size() - 1, sizeq= qlist.size() - 1; 
            TreeNode ans = null;        
            for (int i = sizep, j = sizeq ; i >= 0 && j >= 0 ; i--, j--){
                if (plist.get(i).val == qlist.get(j).val)
                   ans = plist.get(i);
            }
            return ans;
    }
    public boolean fuction(TreeNode node, TreeNode tar, List list){
                if (node == null)
                   return false;
                else if (node.val == tar.val){
                   list.add(node);                           
                   return true;
                }   
                else if (fuction(node.left, tar, list) || fuction(node.right, tar, list)){
                   list.add(node);
                   return true;
                }
                else
                   return false;   
    } 
}
```

#### 

#### d. 其他解法摘录

```java
class Solution {
private TreeNode ans;

public Solution() {
    this.ans = null;
}

private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) return false;
    boolean lson = dfs(root.left, p, q);
    boolean rson = dfs(root.right, p, q);
    if ((lson && rson) || ((root.val == p.val || root.val == q.val) && (lson || rson))) {
        ans = root;
    } 
    return lson || rson || (root.val == p.val || root.val == q.val);
}

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    this.dfs(root, p, q);
    return this.ans;
}
}
```




------

### 

### 第2题

#### 

#### a. 原题陈述

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。

每个 LED 代表一个 0 或 1，最低位在右侧。

给定一个非负整数 *n* 代表当前 LED 亮着的数量，返回所有可能的时间。

#### b. 解题思路

#### 回溯

#### c. 解题代码

```
class Solution {
    List<String> ans = new ArrayList<>();
    int[] array = {1,2,4,8,16,32,1,2,4,8}; //1实体
    int size = array.length;
    public List<String> readBinaryWatch(int num) {
           dfs(0, 0, 0, num);
           return ans;
    }
    public void dfs(int start, int hour, int min, int num){
           if (num == 0){   //2终止
               StringBuilder str = new StringBuilder();
               str.append(hour).append(':');
               if (min < 10)
                  str.append(0);
               str.append(min);
               ans.add(str.toString());   
           }
           for (int i = start ; i <= size - 1 ; i++){  //3遍历
               int temph = hour, tempm = min;
               if (i < 4)
                  hour += array[i];
               else
                  min += array[i];
               if (hour > 11 || min > 59){  //4剪枝
                  hour = temph;   //6回溯!!!!!!!!
                  min = tempm; 
                  continue;
               }
               dfs(i+1, hour, min, num-1);//5下一层
               hour = temph;   //6回溯
               min = tempm;   
           }
    }
}
```

#### 

#### d. 其他解法摘录

暴力

    class Solution {
        public List<String> readBinaryWatch(int num) {
            List<String> res = new ArrayList<>();  
      for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 60; j++) {
                int cnt = Integer.bitCount(i) + Integer.bitCount(j);
                if (cnt == num) {
                    // res.add(String.format("%d:%02d", i, j));
                    StringBuilder sb = new StringBuilder();
                    sb.append(i).append(':');
                    if (j < 10) {
                        sb.append('0');
                    }
                    sb.append(j);
                    res.add(sb.toString());
                }
            }
        }
    
        return res;
    }
    }



------



### 第3题

#### 

#### a. 原题陈述

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。



#### b. 解题思路

#### 回溯

#### c. 解题代码

```
class Solution {
    public boolean exist(char[][] board, String word) {
           int num = word.length() - 1;
           int kuan = board[0].length;
           int gao = board.length;
           for (int i = 0 ; i <= gao - 1 ; i++){
               for (int j = 0 ; j <= kuan - 1 ; j++){
                   if (board[i][j] == word.charAt(0)){
                      boolean[][] check = new boolean[gao][kuan]; 
                      if (dfs(i, j, 0, word, kuan, gao, board, check))
                         return true;   
                   }   
               }          
           }
           return false;
    }
    public boolean dfs(int x, int y, int num, String word, int kuan, int gao, char[][] board, boolean[][] check){
           if (x < 0 || x > gao - 1 || y < 0 || y > kuan - 1){
              check[x][y] = false;//回溯
              return false;
           }   
           if (num == word.length() - 1 && board[x][y] == word.charAt(num))
              return true; 
           if (board[x][y] != word.charAt(num)){
              check[x][y] = false;
              return false;
           }   
           check[x][y] = true;   
           boolean a = false, b = false, c = false, d = false;   
           if (x+1 >= 0 && x+1 <= gao - 1 && y >= 0 && y <= kuan - 1 && !check[x+1][y])   
              a = dfs(x+1, y, num+1, word, kuan, gao, board, check); 
           if (x-1 >= 0 && x-1 <= gao - 1 && y >= 0 && y <= kuan - 1 && !check[x-1][y]) 
              b = dfs(x-1, y, num+1, word, kuan, gao, board, check);
           if (x >= 0 && x <= gao - 1 && y+1 >= 0 && y+1 <= kuan - 1 && !check[x][y+1]) 
              c = dfs(x, y+1, num+1, word, kuan, gao, board, check); 
           if (x >= 0 && x <= gao - 1 && y-1 >= 0 && y-1 <= kuan - 1 && !check[x][y-1]) 
              d = dfs(x, y-1, num+1, word, kuan, gao, board, check);  
           if (a || b || c || d)
              return true;
           else {
              check[x][y] = false;
              return false;
           }      
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public boolean exist(char[][] board, String word) {
            int h = board.length, w = board[0].length;
            boolean[][] visited = new boolean[h][w];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < w; j++) {
                    boolean flag = check(board, visited, i, j, word, 0);
                    if (flag) {
                        return true;
                    }
                }
            }
            return false;
        }
    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {
        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }
    }



------



### 第4题

#### 

#### a. 原题陈述

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集

#### b. 解题思路

#### 回溯

#### c. 解题代码

```
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    ArrayList<Integer> a = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) { 
           dfs(0, nums);
           return ans;
    }        
    public void dfs(int start, int[] nums){
           ArrayList<Integer> b = (ArrayList<Integer>)a.clone();
           ans.add(b);       
           for (int i = start ; i <= nums.length - 1 ; i++){
               a.add(nums[i]);
               dfs(i+1, nums);
               a.remove(a.size()-1);
           }
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        List<Integer> t = new ArrayList<Integer>();
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);
        return ans;
    }
    
    public void dfs(int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        t.add(nums[cur]);
        dfs(cur + 1, nums);
        t.remove(t.size() - 1);
        dfs(cur + 1, nums);
    }
    }



------



### 第5题

#### 

#### a. 原题陈述

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。



#### b. 解题思路

#### 回溯，子集按升序排列

#### c. 解题代码

```
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    ArrayList<Integer> a = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
           dfs(0, a, nums);
           return ans;
    }
    public void dfs(int start, ArrayList<Integer> a, int[] nums){
           if (!ans.contains(a))
              ans.add(a);       
           for (int i = start ; i <= nums.length - 1 ; i++){
               ArrayList<Integer> b = (ArrayList<Integer>)a.clone();
               boolean flag = true;
               int size = b.size();
               for (int j = 0 ; j <= size - 1 ; j++){
                   if (b.get(j) >= nums[i]){
                      b.add(j, nums[i]);
                      flag = false;
                      break;//!!!
                   }   
                }   
                if (flag)
                   b.add(nums[i]);
               dfs(i+1, b, nums);
           }
    }
}
```

#### 

#### d. 其他解法摘录

在递归时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。

    class Solution {
        List<Integer> t = new ArrayList<Integer>();
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return ans;
    }
    
    public void dfs(boolean choosePre, int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.add(nums[cur]);
        dfs(true, cur + 1, nums);
        t.remove(t.size() - 1);
    }
    }


