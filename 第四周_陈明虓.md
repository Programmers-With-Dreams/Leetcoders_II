# 第四周_陈明虓

##  

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢

#### b. 解题思路

#### dp

#### c. 解题代码

```java
class Solution {
    public int climbStairs(int n) {
           int[] dp = new int[n+1];
           dp[0] = 1;
           dp[1] = 1;
           for (int i = 2 ; i <= n ; i++){
               dp[i] = dp[i-1] + dp[i-2];
           }
           return dp[n];
    }
}
```

#### 

#### d. 其他解法摘录

```java
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <=2:
            return n
        dp = [0]*n
        dp[0] = 1
        dp[1] = 2
        for i in range(2,n):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[n-1]



```



------

### 

### 第2题

#### 

#### a. 原题陈述

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int maxSubArray(int[] nums) {
           int pre = nums[0];
           int ans = nums[0];
           for (int i = 1 ; i <= nums.length - 1 ; i++){
               pre = Math.max(pre + nums[i], nums[i]);
               ans = Math.max(ans, pre);
           }
           return ans;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public class Status {
            public int lSum, rSum, mSum, iSum;
    
            public Status(int lSum, int rSum, int mSum, int iSum) {
                this.lSum = lSum;
                this.rSum = rSum;
                this.mSum = mSum;
                this.iSum = iSum;
            }
        }
    
        public int maxSubArray(int[] nums) {
            return getInfo(nums, 0, nums.length - 1).mSum;
        }
    
        public Status getInfo(int[] a, int l, int r) {
            if (l == r) {
                return new Status(a[l], a[l], a[l], a[l]);
            }
            int m = (l + r) >> 1;
            Status lSub = getInfo(a, l, m);
            Status rSub = getInfo(a, m + 1, r);
            return pushUp(lSub, rSub);
        }
    
        public Status pushUp(Status l, Status r) {
            int iSum = l.iSum + r.iSum;
            int lSum = Math.max(l.lSum, l.iSum + r.lSum);
            int rSum = Math.max(r.rSum, r.iSum + l.rSum);
            int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
            return new Status(lSum, rSum, mSum, iSum);
        }
    }
    



------



### 第3题

#### 

#### a. 原题陈述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int rob(int[] nums) {
           int[] dp = new int[nums.length];
           dp[0] = nums[0];
           if (nums.length > 1)
              dp[1] = Math.max(nums[0], nums[1]);
           for (int i = 2 ; i <= nums.length - 1 ; i++){
               dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
           } 
           return dp[nums.length - 1];
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int rob(int[] nums) {
            if (nums == null || nums.length == 0) {
                return 0;
            }
            int length = nums.length;
            if (length == 1) {
                return nums[0];
            }
            int first = nums[0], second = Math.max(nums[0], nums[1]);
            for (int i = 2; i < length; i++) {
                int temp = second;
                second = Math.max(first + nums[i], second);
                first = temp;
            }
            return second;
        }
    }
    


​    



------



### 第4题

#### 

#### a. 原题陈述

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int maxProfit(int[] prices) {
           if (prices.length == 1)
              return 0;
        //    if (prices.length == 2)
        //       return prices[1] - prices[0] > 0 ? prices[1] - prices[0] : 0;    
           int[] dp = new int[3];  //0有票  12  前12天无票
           dp[0] = -prices[0];
           dp[1] = 0;
           dp[2] = 0;
           for (int i = 1 ; i <= prices.length - 1 ; i++){
               int temp1 = dp[0], temp2 = dp[1];
               dp[0] = Math.max(dp[0], dp[2] - prices[i]);
               dp[1] = Math.max(dp[1], temp1 + prices[i]);
               dp[2] = temp2;
           } 
           return dp[1];
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int maxProfit(int[] prices) {
            if (prices.length == 0) {
                return 0;
            }
    
            int n = prices.length;
            int f0 = -prices[0];
            int f1 = 0;
            int f2 = 0;
            for (int i = 1; i < n; ++i) {
                int newf0 = Math.max(f0, f2 - prices[i]);
                int newf1 = f0 + prices[i];
                int newf2 = Math.max(f1, f2);
                f0 = newf0;
                f1 = newf1;
                f2 = newf2;
            }
    
            return Math.max(f1, f2);
        }
    }
    


​    



------



### 第5题

#### 

#### a. 原题陈述

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public boolean canPartition(int[] nums) {
           int size = nums.length;
           if (size == 1)
              return false;  
           int sum = 0, max = 0;
           for (int i = 0 ; i < size ; i++){
               sum += nums[i];
               max = Math.max(max, nums[i]);
           }
           if (sum % 2 == 1)
              return false;  
           int target = sum / 2;
           if (max > target)
              return false;
           boolean[][] dp = new boolean[size][target + 1];
           dp[0][nums[0]] = true;  //?其他i=0均为false
           for (int i = 0 ; i < size ; i++){
               dp[i][0] = true;
           }
           for (int i = 1 ; i < size ; i++){
               for (int j = 1 ; j < target + 1 ; j++){
                   if (nums[i] <= j)
                      dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                   else
                      dp[i][j] = dp[i-1][j];   
               }
           }
           return dp[size-1][target];
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public boolean canPartition(int[] nums) {
            int n = nums.length;
            if (n < 2) {
                return false;
            }
            int sum = 0, maxNum = 0;
            for (int num : nums) {
                sum += num;
                maxNum = Math.max(maxNum, num);
            }
            if (sum % 2 != 0) {
                return false;
            }
            int target = sum / 2;
            if (maxNum > target) {
                return false;
            }
            boolean[] dp = new boolean[target + 1];
            dp[0] = true;
            for (int i = 0; i < n; i++) {
                int num = nums[i];
                for (int j = target; j >= num; --j) {
                    dp[j] |= dp[j - num];
                }
            }
            return dp[target];
        }
    }
    



