# 第七周_陈明虓

##  

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。



#### b. 解题思路

#### dp

#### c. 解题代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int num : nums) sum += num;
        if(S > sum || (S + sum) % 2 == 1) return 0;
        int target = (S + sum) / 2;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int num : nums){
            for(int j = target; j >= num; j--){
                dp[j] = dp[j] + dp[j - num];
            }
        }
        return dp[target];
    }
}

```

#### 

#### d. 其他解法摘录

```java

public class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int[][] dp = new int[nums.length][2001];
        dp[0][nums[0] + 1000] = 1;
        dp[0][-nums[0] + 1000] += 1;
        for (int i = 1; i < nums.length; i++) {
            for (int sum = -1000; sum <= 1000; sum++) {
                if (dp[i - 1][sum + 1000] > 0) {
                    dp[i][sum + nums[i] + 1000] += dp[i - 1][sum + 1000];
                    dp[i][sum - nums[i] + 1000] += dp[i - 1][sum + 1000];
                }
            }
        }
        return S > 1000 ? 0 : dp[nums.length - 1][S + 1000];
    }
}
```



------

### 

### 第2题

#### 

#### a. 原题陈述

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int coinChange(int[] coins, int amount) {
           int[] dp = new int[amount + 1];//dp代表硬币个数
           int n = coins.length;
           Arrays.fill(dp, 100000);
           for (int j = 0 ; j<= amount ; j++){
               if (j % coins[0] == 0)
                  dp[j] = j / coins[0];
           }
           for (int i = 1 ; i < n ; i++){
               for (int j = 0 ; j <= amount ; j++){
                   if (j - coins[i] >= 0)
                      dp[j] = Math.min(1 + dp[j - coins[i]], dp[j]); 
               }
           }
           if (dp[amount] == 100000)
              return -1;
           else 
              return dp[amount];   
    }
}
```

#### 

#### d. 其他解法摘录

dp

    public class Solution {
        public int coinChange(int[] coins, int amount) {
            if (amount < 1) {
                return 0;
            }
            return coinChange(coins, amount, new int[amount]);
        }
    
        private int coinChange(int[] coins, int rem, int[] count) {
            if (rem < 0) {
                return -1;
            }
            if (rem == 0) {
                return 0;
            }
            if (count[rem - 1] != 0) {
                return count[rem - 1];
            }
            int min = Integer.MAX_VALUE;
            for (int coin : coins) {
                int res = coinChange(coins, rem - coin, count);
                if (res >= 0 && res < min) {
                    min = 1 + res;
                }
            }
            count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
            return count[rem - 1];
        }
    }
    



------



### 第3题

#### 

#### a. 原题陈述

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。





#### b. 解题思路

暴力

#### c. 解题代码

```
class Solution {
    public int mySqrt(int x) {
        if (x == 0)
        return 0;
        if (x == 1)
        return 1;
        int left = 1 , right = x -1;
        while (left <= right){
           int mid = left + (right - left) / 2;
           if (x < ((long)(mid + 1) * (mid + 1)) && x >= (long)mid * mid){
              return mid;
           }
           else if (x >= ((long)(mid + 1) * (mid + 1))){
               left = mid + 1;
           }
           else {
               right = mid -1;
           }
        }
        //  if (x <= (left * left +1) && x >=left * left){
        //       return left;
        //    }
        return 0;
    }
}
```

#### 

#### d. 其他解法摘录

二分查找

    class Solution {
        public int mySqrt(int x) {
            int l = 0, r = x, ans = -1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if ((long) mid * mid <= x) {
                    ans = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            return ans;
        }
    }
    




​    



------



### 第4题

#### 

#### a. 原题陈述

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。





#### b. 解题思路

二分

#### c. 解题代码

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
       int left = 0, right = nums.length - 1, a = -1;
       int[] ans = {-1, -1};
       while (left <= right){
             int mid = left + (right - left) / 2;
             if (nums[mid] == target){
                 a = mid;
                 break;
             }
             else if (nums[mid] < target){
                 left = mid + 1;
             }
             else {
                 right = mid - 1;
             }
       }
       if (a == -1){
           return ans;
       }
       ans[0] = a;
       ans[1] = a;
       while ( (ans[0] !=0 ) && ((nums[ans[0] - 1]) == target) ){
             ans[0] = ans[0] - 1;    
        }
       while ( (ans[1] != (nums.length - 1)) && ((nums[ans[1] + 1]) == target) ){
             ans[1] = ans[1] + 1;    
          }
       return ans;
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public int[] searchRange(int[] nums, int target) {
            int leftIdx = binarySearch(nums, target, true);
            int rightIdx = binarySearch(nums, target, false) - 1;
            if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
                return new int[]{leftIdx, rightIdx};
            } 
            return new int[]{-1, -1};
        }
    
        public int binarySearch(int[] nums, int target, boolean lower) {
            int left = 0, right = nums.length - 1, ans = nums.length;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (nums[mid] > target || (lower && nums[mid] >= target)) {
                    right = mid - 1;
                    ans = mid;
                } else {
                    left = mid + 1;
                }
            }
            return ans;
        }
    }
    




​    



------



### 第5题

#### 

#### a. 原题陈述

对链表进行插入排序。

插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。



#### b. 解题思路

插入排序

#### c. 解题代码

```
class Solution {
    public ListNode insertionSortList(ListNode head) {
       if (head == null || head.next == null)
         return head;

         ListNode currentreal = head;
         while (currentreal.next != null){
               currentreal = currentreal.next;
               ListNode current = currentreal;
               ListNode pre = head;
               ListNode prepre = null;
               while ( pre.next != current && (current.val >= pre.val) ){
                     prepre = pre;
                     pre = pre.next;
               } 
               if (pre == head){      //找到表头
                   head = current;
               }
               if (pre.next == current){   //32 
                   pre.next = null;
               }
               current.next = pre;
               if  (prepre != null){     //防止前面没有
               prepre.next = current;
               }
         }
         return head;
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public ListNode insertionSortList(ListNode head) {
            if (head == null) {
                return head;
            }
            ListNode dummyHead = new ListNode(0);
            dummyHead.next = head;
            ListNode lastSorted = head, curr = head.next;
            while (curr != null) {
                if (lastSorted.val <= curr.val) {
                    lastSorted = lastSorted.next;
                } else {
                    ListNode prev = dummyHead;
                    while (prev.next.val <= curr.val) {
                        prev = prev.next;
                    }
                    lastSorted.next = curr.next;
                    curr.next = prev.next;
                    prev.next = curr;
                }
                curr = lastSorted.next;
            }
            return dummyHead.next;
        }
    }
    





