# 第八周_陈明虓

##  

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。

输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。



#### b. 解题思路

回溯

#### c. 解题代码

```java
class Solution {
public:
    int size;
    bool makesquare(vector<int>& matchsticks) {//与困难题同思路
        int total = 0;
        int row[4];
        size = matchsticks.size();
        memset(row, 0, sizeof(row));
        for(auto &stick: matchsticks){
            total += stick;
        }

        sort(matchsticks.begin(), matchsticks.end(), [&](int &a, int &b){
            return a>b;
        });

        if (total % 4 != 0) return false;
        total /= 4;//每边长度
        return dfs(total, row, matchsticks, 0);
    }

    bool dfs(int max, int row[4], const vector<int> & matchsticks, int index){
        if (index == size) return true;

        for (int i = 0; i < 4; ++i){
            if (row[i] + matchsticks[index] <= max){
                row[i] += matchsticks[index];
                if(dfs(max, row, matchsticks, index + 1)) return true;
                row[i] -= matchsticks[index];
            }

            if (row[i] == 0 || row[i] + matchsticks[index] == max){
                break;
            }
        }

        return false;
    }
};

```

#### 

#### d. 其他解法摘录

状态压缩dp

```java


import java.util.HashMap;
import java.util.Collections;

class Solution {
    public List<Integer> nums;
    public int[] sums;
    public int possibleSquareSide;

    public Solution() {
        this.sums = new int[4];
    }

    // Depth First Search function.
    public boolean dfs(int index) {

        // If we have exhausted all our matchsticks, check if all sides of the square are of equal length
        if (index == this.nums.size()) {
            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];
        }

        // Get current matchstick.
        int element = this.nums.get(index);

        // Try adding it to each of the 4 sides (if possible)
        for(int i = 0; i < 4; i++) {
            if (this.sums[i] + element <= this.possibleSquareSide) {
                this.sums[i] += element;
                if (this.dfs(index + 1)) {
                    return true;
                }
                this.sums[i] -= element;
            }
        }

        return false;
    }

    public boolean makesquare(int[] nums) {
        // Empty matchsticks.
        if (nums == null || nums.length == 0) {
            return false;
        }

        // Find the perimeter of the square (if at all possible)
        int L = nums.length;
        int perimeter = 0;
        for(int i = 0; i < L; i++) {
            perimeter += nums[i];
        }

        this.possibleSquareSide =  perimeter / 4;
        if (this.possibleSquareSide * 4 != perimeter) {
            return false;
        }

        // Convert the array of primitive int to ArrayList (for sorting).
        this.nums = Arrays.stream(nums).boxed().collect(Collectors.toList());
        Collections.sort(this.nums, Collections.reverseOrder());
        return this.dfs(0);
    }
}

```



------

### 

### 第2题

#### 

#### a. 原题陈述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int uniquePaths(int m, int n) {
           int[] dp = new int[n + 1];
           for (int i = 1 ; i <= n ; i++){
               dp[i] = 1;
           }
           for (int i = 2 ; i <= m ; i++){
               for (int j = 1 ; j <= n ; j++){
                   if (j == 1)
                      dp[j] = 1;
                   else
                      dp[j] = dp[j - 1] + dp[j];   
               }
           }
           return dp[n];
    }
}
```

#### 

#### d. 其他解法摘录

dp

    class Solution {
        public int uniquePaths(int m, int n) {
            int[][] f = new int[m][n];
            for (int i = 0; i < m; ++i) {
                f[i][0] = 1;
            }
            for (int j = 0; j < n; ++j) {
                f[0][j] = 1;
            }
            for (int i = 1; i < m; ++i) {
                for (int j = 1; j < n; ++j) {
                    f[i][j] = f[i - 1][j] + f[i][j - 1];
                }
            }
            return f[m - 1][n - 1];
        }
    }
    



------



### 第3题

#### 

#### a. 原题陈述

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。





#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int maximalSquare(char[][] matrix) {
           int m = matrix.length, n = matrix[0].length;
           int[][] dp = new int [m + 1][n + 1];
           int ans = 0;
           for (int i = 1 ; i <= m ; i++){
               dp[i][1] = matrix[i - 1][0] - 48;
               ans = Math.max(ans, dp[i][1]);   
           }
           for (int i = 1 ; i <= n ; i++){
               dp[1][i] = matrix[0][i - 1] - 48;
               ans = Math.max(ans, dp[1][i]);
           }
            for (int i = 2 ; i <= m ; i++){
                for (int j = 2 ; j <= n ; j++){
                    if (matrix[i - 1][j - 1] == 49){
                       if (dp[i - 1][j - 1] > 0){
                          dp[i][j] = 1;
                          for (int k = 1 ; k <= dp[i - 1][j - 1] ; k++){
                              if (dp[i][j - k] > 0 && dp[i - k][j] > 0)
                                 dp[i][j] += 1; 
                              else
                                 break;   
                          }
                       }
                       else
                          dp[i][j] = 1;
                    }
                    else
                       dp[i][j] = 0;
                   ans = Math.max(ans, dp[i][j]);
                }
           }
           return ans * ans;
    }
}

```

#### 

#### d. 其他解法摘录

    class Solution {
        public int maximalSquare(char[][] matrix) {
            int maxSide = 0;
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
                return maxSide;
            }
            int rows = matrix.length, columns = matrix[0].length;
            int[][] dp = new int[rows][columns];
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < columns; j++) {
                    if (matrix[i][j] == '1') {
                        if (i == 0 || j == 0) {
                            dp[i][j] = 1;
                        } else {
                            dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                        }
                        maxSide = Math.max(maxSide, dp[i][j]);
                    }
                }
            }
            int maxSquare = maxSide * maxSide;
            return maxSquare;
        }
    }
    





​    



------



### 第4题

#### 

#### a. 原题陈述

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。





#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int maxCoins(int[] nums) {
           int n = nums.length + 2;
           int[][] dp = new int[n][n];
           int[] list = new int[n];
           list[0] = 1;
           list[n - 1] = 1;
           for (int i = 1 ; i < n - 1 ; i++){
                list[i] = nums[i - 1];
           }
           for (int i = 1 ; i <= n - 1 ; i++){
               for (int j = i - 1 ; j >= 0 ; j--){
                   for (int k = j + 1 ; k <= i - 1 ; k++){
                        int cur = list[j] * list[k] * list[i] + dp[j][k] + dp[k][i];
                        dp[j][i] = Math.max(dp[j][i], cur);
                   }
               }
           }System.out.println(dp[2][4]);
           return dp[0][n - 1];
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public int[][] rec;
        public int[] val;
    
        public int maxCoins(int[] nums) {
            int n = nums.length;
            val = new int[n + 2];
            for (int i = 1; i <= n; i++) {
                val[i] = nums[i - 1];
            }
            val[0] = val[n + 1] = 1;
            rec = new int[n + 2][n + 2];
            for (int i = 0; i <= n + 1; i++) {
                Arrays.fill(rec[i], -1);
            }
            return solve(0, n + 1);
        }
    
        public int solve(int left, int right) {
            if (left >= right - 1) {
                return 0;
            }
            if (rec[left][right] != -1) {
                return rec[left][right];
            }
            for (int i = left + 1; i < right; i++) {
                int sum = val[left] * val[i] * val[right];
                sum += solve(left, i) + solve(i, right);
                rec[left][right] = Math.max(rec[left][right], sum);
            }
            return rec[left][right];
        }
    }
    





​    



------



### 第5题

#### 

#### a. 原题陈述

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。



#### b. 解题思路

状态压缩dp

#### c. 解题代码

```
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
           if (k == 1)
              return true;
           int sum = 0, l = nums.length;
           Arrays.sort(nums);
           for (int i = 0 ; i < l ; i++){
               sum += nums[i];
           }
           if (sum % k != 0)
              return false;
           int target = sum / k;   
           if (nums[l - 1] > target)
              return false;
           int all = 1 << l;
           boolean[] dp = new boolean[all]; //dp代表当前选择下可不可以继续得到最终的true
           int[] cur = new int[all];
           dp[0] = true;
           for (int i = 0 ; i < all ; i++){
               if (!dp[i])   //??????? 总是基于 dp[i] = true 的前提下进行状态转移
                  continue;
               for (int j = 0 ; j < l ; j++){
                   if ((i & (1 << j)) != 0)
                      continue;
                   int next = i + (1 << j);
                   if (dp[next])
                      continue;
                   if ((cur[i] % target) + nums[j] <= target){
                      cur[next] = cur[i] + nums[j];
                      dp[next] = true;
                   }   
                   else
                      break;
               }   
           }
           return dp[all - 1];
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
            int sum = 0;
            int targret = 0;
            int b[];
            public boolean canPartitionKSubsets(int[] nums, int k) {
                for (int num : nums) {
                    sum += num;
                }
                b=new int[k];
                int n = nums.length;
            
                if (sum % k != 0)
                    return false;
                targret=sum/k;
                Arrays.sort(nums);
                reverse(nums);
                if (nums[0]>targret)
                    return false;
                return dfs(0,k,nums);
            }
    
            private boolean dfs(int i, int k, int[] nums) {
                if (i==nums.length)
                    return true;
                for (int j = 0; j <k; j++) {
                    if (b[j]+nums[i]<=targret){
                        b[j]+=nums[i];
                        if (dfs(i+1,k,nums))
                            return true;
                        else{
                            b[j]-=nums[i];
                            if (b[j]==0)
                                return false;
                        }
    
                    }
    
                }
                return false;
            }
    
            void reverse(int []a){
                int l=0,r=a.length-1;
                while (l<r){
                    swap(a,l++,r--);
                }
            }
            void swap(int a[],int l,int r){
                int t=a[l];
                a[l]=a[r];
                a[r]=t;
            }
        }
    






