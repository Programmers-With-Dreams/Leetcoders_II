# 第一周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   5    |   5    |  100%  |

## II 本周刷题总结

### 第1题 [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

难度：简单

方法：双指针

#### a. 原题陈述

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

#### b. 解题思路

双指针，i是慢指针，n相当于快指针，n等于nums[i-1]时，就会跳过重复项

#### c. 解题代码

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int i = 0;
        for(int n : nums){
            if(i < 1 || n > nums[i-1])
                nums[i++] = n;
        }
        return i;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

难度：中等

方法：双指针同上

#### a. 原题陈述

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

#### b. 解题思路

双指针，i是慢指针，n相当于快指针，n等于nums[i-2]时，就会跳过重复项

#### c. 解题代码

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int i = 0;
        for(int n : nums){
            if(i < 2 || n != nums[i - 2]){
                nums[i++] = n;
            }
        }
        return i;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

难度：中等

方法：二分法

#### a. 原题陈述

已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。

给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

#### b. 解题思路

用二分法将数组分为两部分，如果nums[start] < nums[mid]说明前半部分有序，然后如果nums[mid] > target && nums[start] <= target说明目标值在前半部分，所以到前半部分找，否则去后半部分找。

#### c. 解题代码

```java
class Solution {
    public boolean search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int start = 0;
        int end = nums.length - 1;
        int mid;
        while (start <= end) {
            mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                return true;
            }
            if (nums[start] == nums[mid]) {
                start++;
                continue;
            }
            //前半部分有序
            if (nums[start] < nums[mid]) {
                //target在前半部分
                if (nums[mid] > target && nums[start] <= target) {
                    end = mid - 1;
                } else {  //否则，去后半部分找
                    start = mid + 1;
                }
            } else {
                //后半部分有序
                //target在后半部分
                if (nums[mid] < target && nums[end] >= target) {
                    start = mid + 1;
                } else {  //否则，去后半部分找
                    end = mid - 1;

                }
            }
        }
        //一直没找到，返回false
        return false;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第4题 [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

难度：中等

方法：二分法

#### a. 原题陈述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

#### b. 解题思路

一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：

![fig1](https://assets.leetcode-cn.com/solution-static/153/1.png)

其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。

我们考虑数组中的最后一个元素 xxx：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 xxx；而在最小值左侧的元素，它们的值一定都严格大于 xxx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为 low\it lowlow，右边界为 high\it highhigh，区间的中点为 pivot\it pivotpivot，最小值就在该区间内。我们将中轴元素 nums[pivot]\textit{nums}[\textit{pivot}]nums[pivot] 与右边界元素 nums[high]\textit{nums}[\textit{high}]nums[high] 进行比较，可能会有以下的三种情况：

第一种情况是 nums[pivot]<nums[high]\textit{nums}[\textit{pivot}] < \textit{nums}[\textit{high}]nums[pivot]<nums[high]。如下图所示，这说明 nums[pivot]\textit{nums}[\textit{pivot}]nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

![fig2](https://assets.leetcode-cn.com/solution-static/153/2.png)

第二种情况是 nums[pivot]>nums[high]\textit{nums}[\textit{pivot}] > \textit{nums}[\textit{high}]nums[pivot]>nums[high]。如下图所示，这说明 nums[pivot]\textit{nums}[\textit{pivot}]nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

![fig3](https://assets.leetcode-cn.com/solution-static/153/3.png)

由于数组不包含重复元素，并且只要当前的区间长度不为 111，pivot\it pivotpivot 就不会与 high\it highhigh 重合；而如果当前的区间长度为 111，这说明我们已经可以结束二分查找了。因此不会存在 nums[pivot]=nums[high]\textit{nums}[\textit{pivot}] = \textit{nums}[\textit{high}]nums[pivot]=nums[high] 的情况。

当二分查找结束时，我们就得到了最小值所在的位置。

#### c. 解题代码

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while(left < right){
            int mid = left + (right-left)/2;
            if(nums[mid] < nums[right]){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        return nums[left];
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第5题 [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

难度：困难

方法：二分法

#### a. 原题陈述

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：

    若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
    若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

#### b. 解题思路

相比于上一题多了一步，即如果(nums[mid] = nums[high]，就将high-1

#### c. 解题代码

```java
class Solution {
    public int findMin(int[] nums) {
        int low = 0, high = nums.length - 1;
        while(low < high){
            int mid = low + (high - low) / 2;
            if(nums[mid] < nums[high]){
                high = mid;
            }else if(nums[mid] > nums[high]){
                low = mid + 1;
            }else{
                high--;
            }
        }
        return nums[high];
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 