# 第五周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   3    |   3    |  100%  |

## II 本周刷题总结

### 第1题 [子数组异或查询](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)

难度：中等

#### a. 原题陈述

![image-20210516181033839](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210516181033839.png)

#### b. 解题思路

![image-20210516181339201](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210516181339201.png)

![image-20210516181415233](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210516181415233.png)

#### c. 解题代码

```java
class Solution {
    public int[] xorQueries(int[] arr, int[][] queries) {
        int n = arr.length;
        int[] xors = new int[n + 1];
        for(int i = 0 ;i < n; i++){
            xors[i + 1] = xors[i] ^ arr[i];
        }
        int m  = queries.length;
        int[] ans = new int[m];
        for(int i = 0; i < m; i++){
            ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1];
        }
        return ans;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度：简单

方法：异或

#### a. 原题陈述

给定一个二叉树，检查它是否是镜像对称的。

#### b. 解题思路

![image-20210516181810900](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210516181810900.png)

#### c. 解题代码

```java
 //迭代
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root.right, root.left);
    }

    public boolean check(TreeNode u, TreeNode v){
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(u);
        q.offer(v);
        while(!q.isEmpty()){
            u = q.poll();
            v = q.poll();
            if(u == null && v == null){
                continue;
            }
            if((u == null || v == null) || (u.val != v.val)){
                return false;
            }

            q.offer(u.left);
            q.offer(v.right);

            q.offer(u.right);
            q.offer(v.left);
        }
        return true;
    } 
}
```

#### d. 其他解法摘录

![image-20210516181922149](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210516181922149.png)

```java
递归
    class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
    }
}

```

------

### 第3题 [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

难度：简单

#### a. 原题陈述

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

#### b. 解题思路

迭代 用栈

#### c. 解题代码

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        Deque<TreeNode> stk = new LinkedList<TreeNode>();
        while(root != null || !stk.isEmpty()){
            while(root != null){
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
```

#### d. 其他解法摘录

```java
递归
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res){
        if(root == null){
            return;
        }

        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
```

------

### 