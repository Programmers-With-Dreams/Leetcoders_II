# 第二周_董成佳

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   2    |   5    |  2/5   |

## II 本周刷题总结

### 第1题 替换空格

难度：中等

类型：字符串

方法：从后向前进行字符串复制

#### a. 原题陈述

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### b. 解题思路

先遍历一遍字符串统计出字符串中空格的数量，由此计算出替换后字符串的长度。接着从字符串后面开始复制和替换，当遇到空格时，想新的数组中填入%20替换。

#### c. 解题代码

```java
public class Solution {
    public String replaceString(String s){
        if (s==null){return null;}
        StringBuffer str = new StringBuffer(s);
        //计算原字符串中有多少个空格
        int spaceNum = 0;
        int length = str.length();
        for (int i=0;i<length;i++){if (str.charAt(i)==' '){spaceNum++;}}
        //求出新的字符串长度
        int oldStr = length -1;
        length += 2*spaceNum;
        int newStr = length-1;
        str.setLength(length);
        while (spaceNum>0 && newStr>=0){
           char ch = str.charAt(oldStr--);
           if (ch==' '){
               str.setCharAt(newStr--,'0');
               str.setCharAt(newStr--,'2');
               str.setCharAt(newStr--,'%');
               spaceNum--;
           }else {
               str.setCharAt(newStr--,ch);
           }
        }

    return str.toString();
    }
}
```

#### d. 其他解法摘录

```java
public class Solution{
    public String replaceSpace(StringBuffer str) {
        StringBuffer res = new StringBuffer();
        int len = str.length() - 1;
        for(int i = len; i>= 0; i--){
            if(str.charAt(i) == ' ')
                res.append("02%");
            else
                res.append(str.charAt(i));
        }
        return res.reverse().toString();
    }
}
```

------

### 第2题 从头到尾打印链表

难度：中等

类型：链表

方法：递归

#### a. 原题陈述

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

#### b. 解题思路

遍历链表，因为是从头遍历链表从尾输出链表，为典型的“先进后出",因此可以考虑用栈来实现，而递归的本质就是一个栈结构，所以要实现反过来输出链表，每当访问到一个结点的时候，先递归输出它后面的结点，再输出该结点本身。

#### c. 解题代码

```java
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode!=null){
            this.printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

#### d. 其他解法摘录

```java
    /**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList ret = new ArrayList();
        ListNode list = listNode;
        ListNode pre = null;
        ListNode next =null;
        while(list!=null){
            next = list.next;
            list.next = pre;
            pre=list;
            list=next;
        }
        while(pre!=null){
            ret.add(pre.val);
            pre = pre.next;
        }
        return ret;
    }
}
```

------

### 第3题 用两个栈实现队列

难度：简单

类型：栈

#### a. 原题陈述

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### b. 解题思路

首先往队列插入元素的时候可以直接将元素插入stack1中，将进行删除操作时，由于栈是“先进后出”，因此可以先将stack1中的元素弹入stack2，这时stack2中的栈顶元素就是最先插入的元素，即实现了元素的反转，可以直接进行删除。

#### c. 解题代码

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
    if(stack2.isEmpty()){
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }else{
        return stack2.pop();
    }
    }
}
```

#### d. 其他解法摘录

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
         stack1.push(node);
    }
    
    public int pop() {
                if (stack2.size() <= 0) {
            while (stack1.size() != 0) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

------

### 第4题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第5题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

