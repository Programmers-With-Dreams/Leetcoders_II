# 第二周_董成佳

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   5    |   5    |  5/5   |

## II 本周刷题总结

### 第1题 替换空格

难度：中等

类型：字符串

方法：从后向前进行字符串复制

#### a. 原题陈述

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### b. 解题思路

先遍历一遍字符串统计出字符串中空格的数量，由此计算出替换后字符串的长度。接着从字符串后面开始复制和替换，当遇到空格时，想新的数组中填入%20替换。

#### c. 解题代码

```java
public class Solution {
    public String replaceString(String s){
        if (s==null){return null;}
        StringBuffer str = new StringBuffer(s);
        //计算原字符串中有多少个空格
        int spaceNum = 0;
        int length = str.length();
        for (int i=0;i<length;i++){if (str.charAt(i)==' '){spaceNum++;}}
        //求出新的字符串长度
        int oldStr = length -1;
        length += 2*spaceNum;
        int newStr = length-1;
        str.setLength(length);
        while (spaceNum>0 && newStr>=0){
           char ch = str.charAt(oldStr--);
           if (ch==' '){
               str.setCharAt(newStr--,'0');
               str.setCharAt(newStr--,'2');
               str.setCharAt(newStr--,'%');
               spaceNum--;
           }else {
               str.setCharAt(newStr--,ch);
           }
        }

    return str.toString();
    }
}
```

#### d. 其他解法摘录

```java
public class Solution{
    public String replaceSpace(StringBuffer str) {
        StringBuffer res = new StringBuffer();
        int len = str.length() - 1;
        for(int i = len; i>= 0; i--){
            if(str.charAt(i) == ' ')
                res.append("02%");
            else
                res.append(str.charAt(i));
        }
        return res.reverse().toString();
    }
}
```

------

### 第2题 从头到尾打印链表

难度：中等

类型：链表

方法：递归

#### a. 原题陈述

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

#### b. 解题思路

遍历链表，因为是从头遍历链表从尾输出链表，为典型的“先进后出",因此可以考虑用栈来实现，而递归的本质就是一个栈结构，所以要实现反过来输出链表，每当访问到一个结点的时候，先递归输出它后面的结点，再输出该结点本身。

#### c. 解题代码

```java
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode!=null){
            this.printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
}
```

#### d. 其他解法摘录

```java
    /**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList ret = new ArrayList();
        ListNode list = listNode;
        ListNode pre = null;
        ListNode next =null;
        while(list!=null){
            next = list.next;
            list.next = pre;
            pre=list;
            list=next;
        }
        while(pre!=null){
            ret.add(pre.val);
            pre = pre.next;
        }
        return ret;
    }
}
```

------

### 第3题 用两个栈实现队列

难度：简单

类型：栈

#### a. 原题陈述

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### b. 解题思路

首先往队列插入元素的时候可以直接将元素插入stack1中，将进行删除操作时，由于栈是“先进后出”，因此可以先将stack1中的元素弹入stack2，这时stack2中的栈顶元素就是最先插入的元素，即实现了元素的反转，可以直接进行删除。

#### c. 解题代码

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
    if(stack2.isEmpty()){
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }else{
        return stack2.pop();
    }
    }
}
```

#### d. 其他解法摘录

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
         stack1.push(node);
    }
    
    public int pop() {
                if (stack2.size() <= 0) {
            while (stack1.size() != 0) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

------

### 第4题 

难度：重建二叉树

类型：树

方法：递归

#### a. 原题陈述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### b. 解题思路

在二叉树的前序遍历中，第一个数字是树的根结点的值，而在中序遍历中根结点的值在序列的中间，在遍历中序遍历序列找到根结点值的位置。则在该位置的左边是左子树的结点的值，在该位置的右边是右子树的结点的值。对于左子树再采取上述的操作，即进行递归调用，最终完成左右子树的重建。

#### c. 解题代码

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0||in.length==0||pre==null||in==null||pre.length!=in.length){return null;}
        return build(pre,0,pre.length-1,in,0,in.length-1);
    }
    private TreeNode build(int[] pre, int preFrom, int preEnd, int[] in, int inFrom, int inEnd){
        if(preFrom>preEnd || inFrom>inEnd){
            return null;
        }
        // 找到中序遍历中的根结点，从而划分左右子树
        TreeNode root = new TreeNode(pre[preFrom]);
        for(int i=inFrom;i<=inEnd;i++){
            if(in[i]==pre[preFrom]){
                int inIndex = i;
                // 注意遍历的起始位置和终止位置
                root.left = build(pre,preFrom+1,preFrom+inIndex-inFrom,in,inFrom,inIndex-1); 
                root.right = build(pre,preFrom+1+inIndex-inFrom,preEnd,in,inIndex+1,inEnd);
            }
        }
        return root;
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in){
//         TreeNode result = null;
        if(pre.length == 0 || in.length == 0 || pre.length != in.length) return null;
        TreeNode result = new TreeNode(pre[0]);
//         result.val = pre[0];
        for(int i = 0;i<in.length;i++){
            if(in[i] == pre[0]){
//                 以i为节点 在先序遍历中，接下来的几个数就是左子树  只是顺序不一样
                result.left = reConstructBinaryTree(subArray(pre,1,i),subArray(in,0,i-1));
                result.right = reConstructBinaryTree(subArray(pre,i+1,pre.length-1),subArray(in,i+1,in.length-1));
            }
            
        }
        return result;
        
    }
    public int[] subArray(int[] arr, int l, int r){
        int[] result = new int[r-l+1];
        for(int i = l;i<=r;i++){
            result[i-l] = arr[i];
        }
        return result;
    }
}    
```

------

### 第5题 

难度：简单

类型：递归

方法：递归

#### a. 原题陈述

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

#### b. 解题思路

由于可以跳一级台阶或者2级台阶，所以它上一步在第n-1或者第n-2步台阶，所以跳上n级台阶的跳法是跳上n-1和跳上n-2级台阶的跳法数之和。

#### c. 解题代码

```java
public class Solution {
    public int jumpFloor(int target) {
        if(target<=2){return target;}
        // 定义a表示F[n-2]项，b表示F[n-1]项
        int a=1,b=1,c=0;
        for(int i=2;i<=target;i++){
            // c=a+b;
            // a=b;
            // b=c;
            //两者等效
            a=a+b;
            b=a-b;
        }
        return a;
    }
}
```

#### d. 其他解法摘录

```java
public class Solution {
    public int JumpFloor(int n) {
        if (n == 1) return 1; 
        if (n == 2) return 2;
        return JumpFloor(n - 1) + JumpFloor(n - 2);
    }
}
```

------

