第七周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   7    |   7    |  100%  |

## II 本周刷题总结

### 第1题 [二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)

难度：简单

方法：深度优先

#### a. 原题陈述

![image-20210523102038697](https://i.loli.net/2021/05/23/GMXube6nmCjFz1R.png)

#### b. 解题思路

![image-20210523103859230](https://i.loli.net/2021/05/23/MkO7supNXPHeqzK.png)

#### c. 解题代码

```java
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        TreeNode a=dfs(root,x);
        TreeNode b=dfs(root,y);
        int c=highTree(root,x,0);
        int d=highTree(root,y,0);
        return (a!=b)&&(c==d);
    }

    public TreeNode dfs(TreeNode root,int n){
        if(root==null)return null;
        if(root.left!=null&&root.left.val==n){
            return root;
        }
        if(root.right!=null&&root.right.val==n){
            return root;
        }
        TreeNode left= dfs(root.left,n);
        TreeNode right= dfs(root.right,n);
        
        return left==null?right:left;
    }

    public int highTree(TreeNode root,int n,int depth){
        if(root==null)return 0;
        if(root.val==n)return depth;
        
        return Math.max(highTree(root.left,n,depth+1),highTree(root.right,n,depth+1));
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [形成两个异或相等数组的三元组数目](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)

难度：中等

方法：递归

#### a. 原题陈述

![image-20210523103128209](https://i.loli.net/2021/05/23/Y2pTa5i4N1dkGqF.png)

#### b. 解题思路

![image-20210523104034628](https://i.loli.net/2021/05/23/MkO7supNXPHeqzK.png)

#### c. 解题代码

```java
class Solution {
    public int countTriplets(int[] arr) {
        int count = 0;
        for(int i = 0; i < arr.length; i++){
            int ans = arr[i];
            for(int k = i + 1; k < arr.length; k++){
                ans ^= arr[k];
                if(ans == 0){
                    count += k - i;
                }
            }
        }
        return count;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [ 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

难度：中等

方法：中序遍历

#### a. 原题陈述

![image-20210523104422299](https://i.loli.net/2021/05/23/UrC27kTdgWAfOps.png)

#### b. 解题思路

中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。

#### c. 解题代码

```java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root.left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    }
}
```

#### d. 其他解法摘录

```java

```

------

### 第4题 [相同的树](https://leetcode-cn.com/problems/same-tree/)

难度：简单

#### a. 原题陈述

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

#### b. 解题思路

![image-20210523104706510](https://i.loli.net/2021/05/23/cJB4bU5iODyL2dX.png)

#### c. 解题代码

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } else if (p == null || q == null) {
            return false;
        } else if (p.val != q.val) {
            return false;
        } else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
    }
}
```

#### d. 其他解法摘录

![image-20210523104826567](https://i.loli.net/2021/05/23/kpnM6tJRbjYwuAZ.png)

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } else if (p == null || q == null) {
            return false;
        }
        Queue<TreeNode> queue1 = new LinkedList<TreeNode>();
        Queue<TreeNode> queue2 = new LinkedList<TreeNode>();
        queue1.offer(p);
        queue2.offer(q);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            TreeNode node1 = queue1.poll();
            TreeNode node2 = queue2.poll();
            if (node1.val != node2.val) {
                return false;
            }
            TreeNode left1 = node1.left, right1 = node1.right, left2 = node2.left, right2 = node2.right;
            if (left1 == null ^ left2 == null) {
                return false;
            }
            if (right1 == null ^ right2 == null) {
                return false;
            }
            if (left1 != null) {
                queue1.offer(left1);
            }
            if (right1 != null) {
                queue1.offer(right1);
            }
            if (left2 != null) {
                queue2.offer(left2);
            }
            if (right2 != null) {
                queue2.offer(right2);
            }
        }
        return queue1.isEmpty() && queue2.isEmpty();
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

------

### 第5题 [找出第 K 大的异或坐标值](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/)

难度：中等

#### a. 原题陈述

![image-20210523104928650](https://i.loli.net/2021/05/23/WVIjkRYZMwNhLbg.png)

#### b. 解题思路

二维前缀和,主要是之后的排序

#### c. 解题代码

```java
class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        final int N = (matrix == null) ? 0 : matrix.length;
        final int M = (N == 0) ? 0 : matrix[0].length;
        int[][] xor = new int[N + 1][M + 1];
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) {
                xor[i + 1][j + 1] = matrix[i][j] ^ xor[i][j + 1] ^ xor[i + 1][j] ^ xor[i][j];
            }
        }
        int idx = 0;
        int[] nums = new int[N * M];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= M; ++j) {
                nums[idx++] = xor[i][j];
            }
        }
        return quickSelect(nums, 0, nums.length - 1, nums.length - k + 1);
    }

    private int quickSelect(int[] nums, int start, int end, int k) {
        if (start == end) {
            return nums[start];
        }
        int left = start;
        int right = end;
        int pivot = nums[start + (end - start) / 2];
        while (left <= right) {
            if (nums[left] < pivot) {
                left++;
            } else if (nums[right] > pivot) {
                right--;
            } else {
                int temp = nums[left];
                nums[left++] = nums[right];
                nums[right--] = temp;
            }
        }
        if (start + k - 1 <= right) {
            return quickSelect(nums, start, right, k);
        }
        if (start + k - 1 >= left) {
            return quickSelect(nums, left, end, start + k - left);
        }
        return nums[right + 1];
    }
}
```

#### d. 其他解法摘录

```java

```

------

### 第6题 [前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)

难度：中等

方法：递归

#### a. 原题陈述

![image-20210523105401427](https://i.loli.net/2021/05/23/iVqkUR45ncTHh8S.png)

#### b. 解题思路

![image-20210523105433259](https://i.loli.net/2021/05/23/Q1hu5XfMaFSI628.png)

#### c. 解题代码

```java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> cnt = new HashMap<String, Integer>();
        for (String word : words) {
            cnt.put(word, cnt.getOrDefault(word, 0) + 1);
        }
        List<String> rec = new ArrayList<String>();
        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {
            rec.add(entry.getKey());
        }
        Collections.sort(rec, new Comparator<String>() {
            public int compare(String word1, String word2) {
                return cnt.get(word1) == cnt.get(word2) ? word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);
            }
        });
        return rec.subList(0, k);
    }
}
```

#### d. 其他解法摘录

![image-20210523105547262](https://i.loli.net/2021/05/23/xaPOYd4RZp2AkhD.png)

```java
    class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> cnt = new HashMap<String, Integer>();
        for (String word : words) {
            cnt.put(word, cnt.getOrDefault(word, 0) + 1);
        }
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<Map.Entry<String, Integer>>(new Comparator<Map.Entry<String, Integer>>() {
            public int compare(Map.Entry<String, Integer> entry1, Map.Entry<String, Integer> entry2) {
                return entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();
            }
        });
        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {
            pq.offer(entry);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        List<String> ret = new ArrayList<String>();
        while (!pq.isEmpty()) {
            ret.add(pq.poll().getKey());
        }
        Collections.reverse(ret);
        return ret;
    }
}
```

------

### 第7题 [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

难度：中简单

方法：遍历二叉树

#### a. 原题陈述

翻转一棵二叉树。

#### b. 解题思路

看代码

#### c. 解题代码

```java
利用前序遍历
class Solution {
        // 先序遍历--从顶向下交换
        public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            // 保存右子树
            TreeNode rightTree = root.right;
            // 交换左右子树的位置
            root.right = invertTree(root.left);
            root.left = invertTree(rightTree);
            return root;
        }
    }

利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            invertTree(root.left); // 递归找到左节点
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
        	return root;
    }
}

利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            root.right = leftNode;
            root.left = rightNode;
            return root;
        }
    }

利用层次遍历
   class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 层次遍历--直接左右交换即可
            if (root == null) return null;
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(root);
            while (!queue.isEmpty()){
                TreeNode node = queue.poll();
                TreeNode rightTree = node.right;
                node.right = node.left;
                node.left = rightTree;
                if (node.left != null){
                    queue.offer(node.left);
                }
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
            return root;
        }
    }
```

#### d. 其他解法摘录

```java
    
```

------

### 

### ### 