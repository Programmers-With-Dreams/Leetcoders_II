# 第六周_陈明虓

##  

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

#### b. 解题思路

#### dp

#### c. 解题代码

```java
class Solution {
    public int nthUglyNumber(int n) {
           int[] dp = new int[n + 1];
           dp[1] = 1;
           for (int i = 2 ; i <= n ; i++){
               long min = Integer.MAX_VALUE;
               for (int j = 1 ; j < i ; j++){
                   long ldp = dp[j];
                   if (ldp * 2 > dp [i - 1]){
                      min = Math.min(min, ldp * 2);
                   continue;
                   }   
                   if (ldp * 3 > dp [i - 1]){
                      min = Math.min(min, ldp * 3);
                      continue;
                   }  
                   if (ldp * 5 > dp [i - 1]){
                      min = Math.min(min, ldp * 5);
                      continue;
                   }  
               }
               dp[i] = (int)min;
           }
           return dp[n];
    }
}
```

#### 

#### d. 其他解法摘录

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for (int i = 2; i <= n; i++) {
            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(num2, num3), num5);
            if (dp[i] == num2) {
                p2++;
            }
            if (dp[i] == num3) {
                p3++;
            }
            if (dp[i] == num5) {
                p5++;
            }
        }
        return dp[n];
    }
}
```



------

### 

### 第2题

#### 

#### a. 原题陈述

一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。

开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。



#### b. 解题思路

记忆化搜索

#### c. 解题代码

```
class Solution {
    public boolean canCross(int[] stones) {
           HashMap<Integer,HashSet<Integer>> dpMap = new HashMap();//int记录第几个石头可到达set记录步数
           int n = stones.length;
           HashSet<Integer> lose = new HashSet(); //存储废弃的石头
           if (n == 1){
              return true;
           }
           if (n == 2){
              if (stones[1] == 1)
                 return true;
              else
                 return false;    
           }
           if (stones[1] > 1)
              return false;
           ArrayList<Integer> dp = new ArrayList();//记录第几个石头（stones下标）可到达j
           dp.add(1); //直接从1开始否则0麻烦！！！！
           dpMap.put(1, new HashSet<Integer>(){{add(1);}});
           for (int i = 2 ; i <= n - 1 ; i++){//判断第i个是否可达
               int size = dp.size();
               for (int j = 0 ; j <= size - 1 ; j++){
                   if (lose.contains(j))
                      continue;
                   else{    
                   for ( Iterator<Integer> it = dpMap.get(dp.get(j)).iterator() ; it.hasNext() ;){   //对第j个可达石头的到达步数遍历
                       int step = it.next();
                       for (int k = step - 1 ; k <= step + 1 ; k++){  //-1 0 1步
                           int k1 = k;
                           if (k1 == stones[i] - stones[dp.get(j)]){
                              if (!dp.contains(i)) 
                                 dp.add(i);
                              if (dpMap.containsKey(i))
                                 dpMap.get(i).add(k1);
                              else{
                                 int x = k1;
                                 dpMap.put(i, new HashSet<Integer>(){{add(x);}});  
                              }
                           }
                           else if ( k1 == step + 1  && k1 < stones[i] - stones[dp.get(j)]){
                                it.remove();//只删除一个step!!!
                                if (dpMap.get(dp.get(j)).isEmpty()){//step为空则删除map!!!
                                   dpMap.remove(dp.get(j));
                                   lose.add(j);
                                }   
                           }
                           else {
                                continue;
                           }
                       }
                   }
                   }
               }
           }
           return dp.contains(n - 1);
    }
}
```

#### 

#### d. 其他解法摘录

dp

    class Solution {
        public boolean canCross(int[] stones) {
            int n = stones.length;
            boolean[][] dp = new boolean[n][n];
            dp[0][0] = true;
            for (int i = 1; i < n; ++i) {
                if (stones[i] - stones[i - 1] > i) {
                    return false;
                }
            }
            for (int i = 1; i < n; ++i) {
                for (int j = i - 1; j >= 0; --j) {
                    int k = stones[i] - stones[j];
                    if (k > j + 1) {
                        break;
                    }
                    dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
                    if (i == n - 1 && dp[i][k]) {
                        return true;
                    }
                }
            }
            return false;
        }
    }



------



### 第3题

#### 

#### a. 原题陈述

给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
           int n = nums.length; 
           int[] dp = new int[n];
           Arrays.sort(nums);
           int maxSize = 1, maxNum = nums[0];
           Arrays.fill(dp, 1);
           for (int i = 0 ; i <= n - 1 ; i++){
               for (int j = 0 ; j < i ; j++){
                   if (nums[i] % nums[j] == 0)  
                      dp[i] = Math.max(dp[i], dp[j] + 1);
               } 
               if (dp[i] >= maxSize){
                   maxSize = dp[i];
                   maxNum = nums[i];
               }
           }
           List<Integer> ans = new ArrayList();
           for (int i = n -1 ; i >= 0 ; i--){
               if (dp[i] == maxSize && maxNum % nums[i] == 0){
                   ans.add(nums[i]);
                   maxNum = nums[i];
                   maxSize--;
               }
           }
           return ans;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public List<Integer> largestDivisibleSubset(int[] nums) {
            Arrays.sort(nums);
            int n = nums.length;
            int[] f = new int[n];
            int[] g = new int[n];
            for (int i = 0; i < n; i++) {
                // 至少包含自身一个数，因此起始长度为 1，由自身转移而来
                int len = 1, prev = i;
                for (int j = 0; j < i; j++) {
                    if (nums[i] % nums[j] == 0) {
                        // 如果能接在更长的序列后面，则更新「最大长度」&「从何转移而来」
                        if (f[j] + 1 > len) {
                            len = f[j] + 1;
                            prev = j;
                        }
                    }
                }
                // 记录「最终长度」&「从何转移而来」
                f[i] = len;
                g[i] = prev;
            }
            
            // 遍历所有的 f[i]，取得「最大长度」和「对应下标」
            int max = -1, idx = -1;
            for (int i = 0; i < n; i++) {
                if (f[i] > max) {
                    idx = i;
                    max = f[i];
                }
            }
    
            // 使用 g[] 数组回溯出具体方案
            List<Integer> ans = new ArrayList<>();
            while (ans.size() != max) {
                ans.add(nums[idx]);
                idx = g[idx];
            }
            return ans;
        }
    }
    



​    



------



### 第4题

#### 

#### a. 原题陈述

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
           int n = wordDict.size();
           int l = s.length();
           boolean[] dp = new boolean[l];
           HashSet<Integer> num = new HashSet();  
           for (int i = 0 ; i < n ; i++){
               num.add(wordDict.get(i).length());
           }      
           for (int i = 0 ; i < l ; i++){
               if (num.contains(i + 1)){
                  String test1 = s.substring(0, i + 1);  //i+1!!!
                  if (wordDict.contains(test1)){
                     dp[i] = true;
                     continue;   //要continue
                  }
               }
               for (int j : num){
                   if (i >= j){
                   String test2 = s.substring(i - j + 1, i + 1);
                   dp[i] = dp[i - j] && wordDict.contains(test2);
                   if (dp[i])    //防止ture被false覆盖
                      break;
                   }
               } 
           }
           return dp[l - 1];
    }
}
```

#### 

#### d. 其他解法摘录

    public class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {
            Set<String> wordDictSet = new HashSet(wordDict);
            boolean[] dp = new boolean[s.length() + 1];
            dp[0] = true;
            for (int i = 1; i <= s.length(); i++) {
                for (int j = 0; j < i; j++) {
                    if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                        dp[i] = true;
                        break;
                    }
                }
            }
            return dp[s.length()];
        }
    }




​    



------



### 第5题

#### 

#### a. 原题陈述

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。





#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int rob(TreeNode root) {
           int[] ans = dfs(root);
           return Math.max(ans[0], ans[1]);       
    }
    public int[] dfs(TreeNode node){
           if (node == null)
              return new int[]{0, 0};
           int[] l = dfs(node.left);
           int[] r = dfs(node.right);
           int[] cur = new int[2];
           cur[0] = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
           cur[1] = node.val + l[0] + r[0];
           return cur;
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        Map<TreeNode, Integer> f = new HashMap<TreeNode, Integer>();
        Map<TreeNode, Integer> g = new HashMap<TreeNode, Integer>();
    
        public int rob(TreeNode root) {
            dfs(root);
            return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0));
        }
    
        public void dfs(TreeNode node) {
            if (node == null) {
                return;
            }
            dfs(node.left);
            dfs(node.right);
            f.put(node, node.val + g.getOrDefault(node.left, 0) + g.getOrDefault(node.right, 0));
            g.put(node, Math.max(f.getOrDefault(node.left, 0), g.getOrDefault(node.left, 0)) + Math.max(f.getOrDefault(node.right, 0), g.getOrDefault(node.right, 0)));
        }
    }
    




