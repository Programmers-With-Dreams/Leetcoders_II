# 第三周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|        |        |        |

## II 专题回顾

### DFS--深度优先搜索

### 第1题  [岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

#### 1. 算例分析

题目类型: 模板题

算法分析(递归实现):

1. 全局dfs节点(i,j)，每次取res(初始化为0)和dfs(i,j,grid)的最大值;
   1. dfs(i,j,grid),返回此次搜索的岛屿面积num
      1. 若i,j越界或者grid(i,j)==0,返回0;
      2. grid(i,j) =0;
      3. 返回1+dfs(i-1,j,grid)+dfs(i+1,j,grid)+dfs(i,j-1,grid)+dfs(i,j+1,grid);
2. 返回res.

算法分析(栈实现):

1. 全局遍历节点，当grid(i,j)为1时，进行如下处理：
   1. 初始化local_area为1，grid(i,j)置0，初始化栈并加入(i,j);
   2. 栈不为空则循环处理：
      1. 出栈一元素，判断是否越界与grid(i,j)是否为1；
      2. 若grid(i,j)为1，grid(i,j)置0，++local_area，入栈；
   3. max_area在max_area与local_area中取最大值；
2. 返回max_area.

#### 2. 代码复现

```java
class Solution {// 递归实现 77.34% 75.55%
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                res = Integer.max(res, dfs(i, j, grid));
            }
        }
        return res;
    }
    private int dfs(int i, int j, int[][] grid){
        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return 0;
        grid[i][j] = 0;
        return 1 + dfs(i-1,j,grid) + dfs(i+1,j,grid) + dfs(i,j-1,grid) + dfs(i,j+1,grid);
    }
}
----------------------------
----------------------------
class Solution {// 栈实现 13.12% 99.55%
    int[] dir = {-1, 0, 1, 0, -1};

    public int maxAreaOfIsland(int[][] grid) {
        int local_area, max_area = 0, x, y;
        for(int i = 0; i < grid.length; ++i){
            for(int j = 0; j < grid[0].length; ++j){
                if(grid[i][j]==1){
                    local_area = 1;// 开始处理
                    grid[i][j] = 0;
                    Stack<int[]> island = new Stack<>();
                    island.push(new int[]{i,j});
                    while(!island.isEmpty()){
                        int[] tmp = island.pop();
                        for(int k = 0; k < 4; k++){
                            x = tmp[0] + dir[k]; y = tmp[1] + dir[k+1];
                            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y]==1){
                                grid[x][y] = 0;// 开始处理
                                ++local_area;
                                island.push(new int[]{x,y});
                            }
                        }
                    }
                    max_area = Integer.max(max_area, local_area);
                }
            }
        }
        return max_area;
    }
}
```

------

### 第2题  [省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

#### 1. 算例分析

题目类型: 无向图中的连通域,深度优先搜索进行标记

算法分析:

1. 构造访问矩阵visited与省份数量count;
2. 对每个城市循环遍历：
   1. visited[i] 为false时，dfs(isConnected, i, visited)--将i和它的朋友们visited对应值置true
      1. visited[i]置true;
      2. 对每个城市进行遍历，若isConnected(i,k)==1且k未被访问过，dfs(isConnected, k, visited);
   2. count++
3. 返回count.

#### 2. 代码复现

```java
class Solution {// 100.00% 96.94%
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int count = 0;
        for(int i = 0; i < n; ++i){
            if(!visited[i]){
                dfs(isConnected, i, visited);
                ++count;// 圈子数量
            }
        } 
        return count;
    }

    private void dfs(int[][] isConnected, int i, boolean[] visited){
        visited[i] = true;
        for(int k = 0; k < isConnected.length; ++k){
            if(isConnected[i][k] == 1 && !visited[k])
                dfs(isConnected, k, visited);
        }
    }
}
```

------

### 第3题  

#### 1. 算例分析

题目类型: 

算法分析:



#### 2. 代码复现

```java

```

------

### 第4题  

#### 1. 算例分析

题目类型: 

算法分析:



#### 2. 代码复现

```java

```

------

### 第5题  

#### 1. 算例分析

题目类型: 

算法分析:



#### 2. 代码复现

```java

```

------

