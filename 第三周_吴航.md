# 第一周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   5    |   5    |  100%  |

## II 本周刷题总结

### 第1题 [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

难度：简单

#### a. 原题陈述

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

#### b. 解题思路

首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。

注意到当房屋数量不超过两间时，最多只能偷窃一间房屋，因此不需要考虑首尾相连的问题。如果房屋数量大于两间，就必须考虑首尾相连的问题，第一间房屋和最后一间房屋不能同时偷窃。

如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。

假设数组 nums\textit{nums}nums 的长度为 nnn。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0,n−2][0, n-2][0,n−2]；如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1,n−1][1, n-1][1,n−1]。在确定偷窃房屋的下标范围之后，即可用第 198 题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 nnn 间房屋中可以偷窃到的最高总金额。

假设偷窃房屋的下标范围是 [start,end][\textit{start},\textit{end}][start,end]，用 dp[i]\textit{dp}[i]dp[i] 表示在下标范围 [start,i][\textit{start},i][start,i] 内可以偷窃到的最高总金额，那么就有如下的状态转移方程：

dp[i]=max⁡(dp[i−2]+nums[i],dp[i−1])\textit{dp}[i] = \max(\textit{dp}[i-2]+\textit{nums}[i], \textit{dp}[i-1]) dp[i]=max(dp[i−2]+nums[i],dp[i−1])

边界条件为：

{dp[start]=nums[start]只有一间房屋，则偷窃该房屋dp[start+1]=max⁡(nums[start],nums[start+1])只有两间房屋，偷窃其中金额较高的房屋\begin{cases} \textit{dp}[\textit{start}] = \textit{nums}[\textit{start}] & 只有一间房屋，则偷窃该房屋 \\ \textit{dp}[\textit{start}+1] = \max(\textit{nums}[\textit{start}], \textit{nums}[\textit{start}+1]) & 只有两间房屋，偷窃其中金额较高的房屋 \end{cases} {dp[start]=nums[start]dp[start+1]=max(nums[start],nums[start+1])只有一间房屋，则偷窃该房屋只有两间房屋，偷窃其中金额较高的房屋

计算得到 dp[end]\textit{dp}[\textit{end}]dp[end] 即为下标范围 [start,end][\textit{start},\textit{end}][start,end] 内可以偷窃到的最高总金额。

分别取 (start,end)=(0,n−2)(\textit{start},\textit{end})=(0,n-2)(start,end)=(0,n−2) 和 (start,end)=(1,n−1)(\textit{start},\textit{end})=(1,n-1)(start,end)=(1,n−1) 进行计算，取两个 dp[end]\textit{dp}[\textit{end}]dp[end] 中的最大值，即可得到最终结果。

#### c. 解题代码

```java
class Solution {
    public int rob(int[] nums) {
        int length = nums.length;
        if(length == 1){
            return nums[0];
        }else if(length == 2){
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0 , length-2), robRange(nums, 1, length-1));
    }

    private int robRange(int[] nums, int start, int end){
        int first = nums[start], second = Math.max(nums[start], nums[start+1]);
        for(int i = start+2; i <= end; i++){
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

难度：困难

#### a. 原题陈述

给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。

题目数据保证总会存在一个数值和不超过 k 的矩形区域。

#### b. 解题思路

有序集合

#### c. 解题代码

```java
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int ans = Integer.MIN_VALUE;
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m; ++i) { // 枚举上边界
            int[] sum = new int[n];
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                TreeSet<Integer> sumSet = new TreeSet<Integer>();
                sumSet.add(0);
                int s = 0;
                for (int v : sum) {
                    s += v;
                    Integer ceil = sumSet.ceiling(s - k);
                    if (ceil != null) {
                        ans = Math.max(ans, s - ceil);
                    }
                    sumSet.add(s);
                }
            }
        }
        return ans;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [递增顺序搜索树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

难度：简单

#### a. 原题陈述

给你一棵二叉搜索树，请你 **按中序遍历** 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

#### b. 解题思路

一边遍历一边生成

#### c. 解题代码

```java
class Solution {
    TreeNode pre;
    public TreeNode increasingBST(TreeNode root) {
        if(root==null) return null;
        TreeNode Head,p=root;
        while(p.left!=null) p=p.left;
        Head=p;
        Inorder(root);
        return Head;
    }
    private void Inorder(TreeNode p){
        if(p!=null){
            Inorder(p.left);
            if(pre!=null)pre.right=p;
            p.left = null;
            pre=p;
            Inorder(p.right);
        }
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

