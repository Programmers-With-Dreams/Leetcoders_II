# 第一周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   5    |   5    |  100%  |

## II 本周刷题总结

### 第1题 [丑数](https://leetcode-cn.com/problems/ugly-number/)

难度：简单

#### a. 原题陈述

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

#### b. 解题思路

对能被2,3,5整除的数不断除2,3,5，最后剩1就是，剩0就不是

#### c. 解题代码

```java
class Solution {
    public boolean isUgly(int n) {
        if(n <= 0)
            return false;
        int factors[] = {2,3,5};
        for(int factor:factors){
            while(n % factor == 0){
                n /= factor;
            }
        }
        return n == 1;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

难度：中等

方法：三指针

#### a. 原题陈述

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

#### b. 解题思路

如果一个丑数nums[pi]通过乘以i可以得到下一个丑数，那么这个丑数nums[pi]就永远失去了同i相乘的资格（没有必要再乘了），我们把pi++让nums[pi]指向下一个丑数即可。

#### c. 解题代码

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        int p2 = 1,p3 = 1, p5 = 1;
        for(int i = 2; i <= n;i++){
            int num2 = dp[p2] * 2,num3 = dp[p3] * 3,num5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(num2,num3), num5);
            if(dp[i] == num2){
                p2++;
            }
            if(dp[i] == num3){
                p3++;
            }
            if(dp[i] == num5){
                p5++;
            }
        }
        return dp[n];
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [最大数](https://leetcode-cn.com/problems/largest-number/)

难度：中等

#### a. 原题陈述

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

#### b. 解题思路

- 将nums中的各数字转化成字符串格式,保存在numsToWord中，
- 应用以上自定义排序规则，对numsToWord中字符串执行排序
- 拼接numsToWord中的所有字符串

#### c. 解题代码

```java
class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String numsToWord[] = new String[n];
        for(int i = 0; i < n; i++){
            numsToWord[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(numsToWord,(a,b)->{
            return (b+a).compareTo(a+b);
        });
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < n; i++){
            sb.append(numsToWord[i]);
        }
        String res = sb.toString();
        return res.charAt(0) == '0'?"0":res;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第4题 [ 二叉搜索树节点最小距离](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

难度：简单

方法：递归

#### a. 原题陈述

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

#### b. 解题思路

考虑对升序数组 a求任意两个元素之差的最小值，答案一定为相邻两个元素之差的最小值，

本题要求二叉搜索树任意两节点差的最小值，而我们知道二叉搜索树有个性质为二叉搜索树中序遍历得到的值序列是递增有序的，因此我们只要得到中序遍历后的值序列即能用上文提及的方法来解决。

朴素的方法是经过一次中序遍历将值保存在一个数组中再进行遍历求解，我们也可以在中序遍历的过程中用 pre\textit{pre}pre 变量保存前驱节点的值，这样即能边遍历边更新答案，不再需要显式创建数组来保存，需要注意的是 pre\textit{pre}pre 的初始值需要设置成任意负数标记开头，下文代码中设置为 −1。

#### c. 解题代码

```java
class Solution {
    int pre;
    int ans;

    public int minDiffInBST(TreeNode root) {
        ans = Integer.MAX_VALUE;
        pre = -1;
        dfs(root);
        return ans;
    }

    public void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        if (pre == -1) {
            pre = root.val;
        } else {
            ans = Math.min(ans, root.val - pre);
            pre = root.val;
        }
        dfs(root.right);
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第5题 [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

难度：困中等

#### a. 原题陈述

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

    Trie() 初始化前缀树对象。
    void insert(String word) 向前缀树中插入字符串 word 。
    boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
    boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

#### b. 解题思路

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

    指向子节点的指针数组 children\textit{children}children。对于本题而言，数组长度为 262626，即小写英文字母的数量。此时 children[0]\textit{children}[0]children[0] 对应小写字母 aaa，children[1]\textit{children}[1]children[1] 对应小写字母 bbb，…，children[25]\textit{children}[25]children[25] 对应小写字母 zzz。
    布尔字段 isEnd\textit{isEnd}isEnd，表示该节点是否为字符串的结尾。

插入字符串

我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：

    子节点存在。沿着指针移动到子节点，继续处理下一个字符。
    子节点不存在。创建一个新的子节点，记录在 children\textit{children}children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。

重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

查找前缀

我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：

    子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
    子节点不存在。说明字典树中不包含该前缀，返回空指针。

重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。

若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd\textit{isEnd}isEnd 为真，则说明字典树中存在该字符串。

#### c. 解题代码

```java
class Trie {
    private Trie[] children;
    private boolean isEnd;

    /** Initialize your data structure here. */
    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie node = this;
        for(int i = 0; i < word.length(); i++){
            char ch = word.charAt(i);
            int index = ch - 'a';
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix){
        Trie node = this;
        for(int i = 0; i < prefix.length(); i++){
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if(node.children[index] == null){
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

#### d. 其他解法摘录

```java
    
```

------

### 