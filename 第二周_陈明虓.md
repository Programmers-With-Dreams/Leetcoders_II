# 第二周_陈明虓

## 

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

#### 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

#### b. 解题思路

回溯

#### c. 解题代码

#### 

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    ArrayList<Integer> list = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
           Map<Integer, Boolean> map = new HashMap<>();
           for (int i = 0 ; i <= nums.length - 1 ; i++){
               map.put(i, false);
           } 
           dfs(map, nums);
           return ans;
    }
    public void dfs(Map<Integer, Boolean> map, int[] nums){
           if (list.size() == nums.length){
              List<Integer> list1 = (List<Integer>)list.clone(); 
              ans.add(list1);
              //ans.add(new ArrayList<Integer>(list));
              return;
           } 
           for (int i = 0 ; i <= nums.length - 1 ; i++){
               if (map.get(i))
                  continue;
               else {
                  list.add(nums[i]); 
                  map.put(i, true);
                  dfs(map, nums);
                  map.put(i, false);
                  list.remove(list.size()-1);
               }   
           }  
    }
}
```



#### d. 其他解法摘录

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();

        List<Integer> output = new ArrayList<Integer>();
        for (int num : nums) {
            output.add(num);
        }

        int n = nums.length;
        backtrack(n, output, res, 0);
        return res;
    }

    public void backtrack(int n, List<Integer> output, List<List<Integer>> res, int first) {
        // 所有数都填完了
        if (first == n) {
            res.add(new ArrayList<Integer>(output));
        }
        for (int i = first; i < n; i++) {
            // 动态维护数组
            Collections.swap(output, first, i);
            // 继续递归填下一个数
            backtrack(n, output, res, first + 1);
            // 撤销操作
            Collections.swap(output, first, i);
        }
    }
}

```



------

### 

### 第2题

#### 

#### a. 原题陈述

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

#### b. 解题思路

#### 回溯

#### c. 解题代码

```
class Solution {
    List<String> ans = new ArrayList<>();
    StringBuffer list = new StringBuffer();
    public List<String> letterCombinations(String digits) {
           if(digits.isEmpty())
              return ans;
           Map<Character,String> map = new HashMap<>();
           map.put('2',"abc");
           map.put('3',"def");
           map.put('4',"ghi");
           map.put('5',"jkl");
           map.put('6',"mno");
           map.put('7',"pqrs");
           map.put('8',"tuv");
           map.put('9',"wxyz");
           dfs(0, digits, map);
           return ans;
    }
    public void dfs(int cur, String digits, Map<Character,String> map){
           if (cur >= digits.length()){
              ans.add(list.toString());
              return;
           }
           String tar = map.get(digits.charAt(cur));
           for (int i = 0 ; i <= tar.length() - 1 ; i++){
               list.append(tar.charAt(i));
               dfs(cur+1, digits, map);
               list.deleteCharAt(list.length()-1);
           }             
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public List<String> letterCombinations(String digits) {
            List<String> combinations = new ArrayList<String>();
            if (digits.length() == 0) {
                return combinations;
            }
            Map<Character, String> phoneMap = new HashMap<Character, String>() {{
                put('2', "abc");
                put('3', "def");
                put('4', "ghi");
                put('5', "jkl");
                put('6', "mno");
                put('7', "pqrs");
                put('8', "tuv");
                put('9', "wxyz");
            }};
            backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
            return combinations;
        }
    
        public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
            if (index == digits.length()) {
                combinations.add(combination.toString());
            } else {
                char digit = digits.charAt(index);
                String letters = phoneMap.get(digit);
                int lettersCount = letters.length();
                for (int i = 0; i < lettersCount; i++) {
                    combination.append(letters.charAt(i));
                    backtrack(combinations, phoneMap, digits, index + 1, combination);
                    combination.deleteCharAt(index);
                }
            }
        }
    }
    



------



### 第3题

#### 

#### a. 原题陈述

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。



#### b. 解题思路

#### 堆排序

#### c. 解题代码

```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
           if (k == 0)
           return new int[0];
           int[] ans = new int[k];
           for (int i = 0 ; i <= k - 1 ; i++){
               ans[i] = arr[i];
           }
           buildMaxHeap(ans, k);
           for (int i = k ; i <= arr.length - 1 ; i++){
               if (arr[i] < ans[0]){
                   ans[0] = arr[i];
                   adjustHeap(ans, 0, k);
               }      
           }
           return ans;
    }
    public void buildMaxHeap(int[] nums, int size){
           for (int i = size / 2 ; i >= 0 ; i--){
               adjustHeap(nums, i, size);
           }
    }
    public void adjustHeap(int[] nums, int i, int size){
           int maxnode = i, left = i * 2 + 1, right = i * 2 + 2;
           if (left <= size - 1 && nums[left] > nums[maxnode])
              maxnode = left;
           if (right <= size - 1 && nums[right] > nums[maxnode])
              maxnode = right;   
           if (maxnode != i){
              swap(nums, maxnode, i);
              adjustHeap(nums, maxnode, size);  
           }
    }
    public void swap(int[] nums, int a, int b){
           int temp = nums[a];
           nums[a] = nums[b];
           nums[b] = temp;     
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int[] getLeastNumbers(int[] arr, int k) {
            randomizedSelected(arr, 0, arr.length - 1, k);
            int[] vec = new int[k];
            for (int i = 0; i < k; ++i) {
                vec[i] = arr[i];
            }
            return vec;
        }
    
        private void randomizedSelected(int[] arr, int l, int r, int k) {
            if (l >= r) {
                return;
            }
            int pos = randomizedPartition(arr, l, r);
            int num = pos - l + 1;
            if (k == num) {
                return;
            } else if (k < num) {
                randomizedSelected(arr, l, pos - 1, k);
            } else {
                randomizedSelected(arr, pos + 1, r, k - num);
            }
        }
    
        // 基于随机的划分
        private int randomizedPartition(int[] nums, int l, int r) {
            int i = new Random().nextInt(r - l + 1) + l;
            swap(nums, r, i);
            return partition(nums, l, r);
        }
    
        private int partition(int[] nums, int l, int r) {
            int pivot = nums[r];
            int i = l - 1;
            for (int j = l; j <= r - 1; ++j) {
                if (nums[j] <= pivot) {
                    i = i + 1;
                    swap(nums, i, j);
                }
            }
            swap(nums, i + 1, r);
            return i + 1;
        }
    
        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    
    



------



### 第4题

#### 

#### a. 原题陈述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

#### b. 解题思路

#### 堆排序

#### c. 解题代码

```
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
           Map<Integer, Integer> map = new HashMap<>();
           for (int i = 0 ; i <= nums.length - 1 ; i++){
               if (map.containsKey(nums[i]))
                  map.put(nums[i], map.get(nums[i])+1);
               else
                  map.put(nums[i], 1);   
           } 
           List<Integer> list = new ArrayList<>();
           for (Integer i : map.keySet()){
               list.add(i);
           } 
           int[] ans = new int[k];
           for (int i = 0 ; i <= k - 1 ; i++){
               ans[i] = list.get(i);
           }
           buildMinHeap(ans, k, map);
           for (int i = k ; i <= list.size() - 1 ; i++){
               if (map.get((list.get(i))) > map.get(ans[0])) 
                  ans[0] = list.get(i);
                  adjustHeap(ans, 0, k, map);              
           }
           return ans;
    }
    public void buildMinHeap(int[] nums, int size, Map<Integer, Integer> map){
           for (int i = size / 2 ; i >= 0 ; i--){
               adjustHeap(nums, i, size, map);
           }     
    }
    public void adjustHeap(int[] nums, int i, int size,  Map<Integer, Integer> map){
           int maxnode = i, left = i * 2 + 1, right = i * 2 + 2;
           if (left < size && map.get(nums[left]) < map.get(nums[maxnode]))
              maxnode = left;
           if (right < size && map.get(nums[right]) < map.get(nums[maxnode]))
              maxnode = right;
           if (maxnode != i){
              swap(nums, maxnode, i);
              adjustHeap(nums, maxnode, size, map);
           }              
    }
    public void swap(int[] nums, int a, int b){
           int temp = nums[a];
           nums[a] = nums[b];
           nums[b] = temp;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int[] topKFrequent(int[] nums, int k) {
            Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();
            for (int num : nums) {
                occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
            }
    
            List<int[]> values = new ArrayList<int[]>();
            for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {
                int num = entry.getKey(), count = entry.getValue();
                values.add(new int[]{num, count});
            }
            int[] ret = new int[k];
            qsort(values, 0, values.size() - 1, ret, 0, k);
            return ret;
        }
    
        public void qsort(List<int[]> values, int start, int end, int[] ret, int retIndex, int k) {
            int picked = (int) (Math.random() * (end - start + 1)) + start;
            Collections.swap(values, picked, start);
            
            int pivot = values.get(start)[1];
            int index = start;
            for (int i = start + 1; i <= end; i++) {
                if (values.get(i)[1] >= pivot) {
                    Collections.swap(values, index + 1, i);
                    index++;
                }
            }
            Collections.swap(values, start, index);
    
            if (k <= index - start) {
                qsort(values, start, index - 1, ret, retIndex, k);
            } else {
                for (int i = start; i <= index; i++) {
                    ret[retIndex++] = values.get(i)[0];
                }
                if (k > index - start + 1) {
                    qsort(values, index + 1, end, ret, retIndex, k - (index - start + 1));
                }
            }
        }
    }
    



------



### 第5题

#### 

#### a. 原题陈述

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。



#### b. 解题思路

#### 堆排序

#### c. 解题代码

```
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
           int size = matrix[0].length;
           int[] ans = new int[k];
           int x = 0, y = 0;
           for (int i = 0 ; i < k ; i++){
               ans[i] = matrix[x][y];
               y++;
               if (y >= size){
                  x++;
                  y = 0;
               }   
           }
           buildMaxHeap(ans, k);
           while (x < size){
                 if (y == size - 1){
                    y++;
                    if (y >= size){
                       x++;
                       y = 0;
                       }                   
                    continue; 
                 }
                 else if (y == 0 && matrix[x][y] >= ans[0])
                    break;
                 else {
                      if (matrix[x][y] < ans[0]){
                         ans[0] = matrix[x][y];
                         adjustHeap(ans, 0, k);
                      } 
                 }       
                 y++;
                 if (y >= size){
                    x++;
                    y = 0;
               }   
           }
           return ans[0];           
    }
    public void buildMaxHeap(int[] nums, int size){
           for (int i = size / 2 ; i >= 0 ; i--){
               adjustHeap(nums, i, size);
           }     
    }
    public void adjustHeap(int[] nums, int i, int size){
           int maxnode = i, left = i * 2 + 1, right = i * 2 + 2;
           if (left < size && nums[left] > nums[maxnode])
              maxnode = left;
           if (right < size && nums[right] > nums[maxnode])
              maxnode = right;
           if (maxnode != i){
              swap(nums, maxnode, i);
              adjustHeap(nums, maxnode, size);
           }              
    }
    public void swap(int[] nums, int a, int b){
           int temp = nums[a];
           nums[a] = nums[b];
           nums[b] = temp;
    }
}
```

#### 

#### d. 其他解法摘录

二分法

    class Solution {
        public int kthSmallest(int[][] matrix, int k) {
            int n = matrix.length;
            int left = matrix[0][0];
            int right = matrix[n - 1][n - 1];
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (check(matrix, mid, k, n)) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            return left;
        }
    
        public boolean check(int[][] matrix, int mid, int k, int n) {
            int i = n - 1;
            int j = 0;
            int num = 0;
            while (i >= 0 && j < n) {
                if (matrix[i][j] <= mid) {
                    num += i + 1;
                    j++;
                } else {
                    i--;
                }
            }
            return num >= k;
        }
    }
    
    

