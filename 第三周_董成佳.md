# 第三周_董成佳

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   3    |   5    |  3/5   |

## II 本周刷题总结

### 第1题 二进制中1的个数

难度：中等

类型：数字

方法：位运算

#### a. 原题陈述

输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

#### b. 解题思路

把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中的最右边的一个1变为0。

#### c. 解题代码

```java
public class Solution {
    public int NumberOf1(int n) {
        int count =0;
        while(n!=0){
            count++;
            n=n&(n-1);
        }
        return count;

    }
}
```

#### d. 其他解法摘录

```java
public class Solution {
    public int NumberOf1(int n) {
int count = 0;
        int flag = 1;
        while (flag !=  0) {
            if((flag & n) != 0) count ++;

            flag = flag << 1;
        }
        return count;
    }
}
```

------

### 第2题 数值的整数次方

难度：中等

类型：数学

#### a. 原题陈述

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。

#### b. 解题思路

思路很简单，主要是要考虑指数为负数、0和正数的情况，以及由于底数是浮点数，判断是否为0不能直接base==0,需重新定义一个函数来判断。

#### c. 解题代码

```java
public class Solution {
    public double Power(double base, int exponent) {
        if(equal(base,0.0) && exponent==0){
            return 0;
        }else if(exponent ==1){return base;}
         else if(exponent > 1){
             double result = 1;
             for(int i=1;i<=exponent;i++){
                 result*=base;
             }
             return result;
           }else{
             double result = 1;
             for(int i=-1;i>=exponent;i--){
                 result*=base;
             }
             return 1/result;
         }
  }
    // 判断底数是否为0
    private boolean equal(double num1, double num2){
        if((num1-num2)<0.0000001 &&(num1-num2)>-0.0000001){
            return true;
        }else{
            return false;
        }
}
}
```

#### d. 其他解法摘录

NP

```java
public class Solution {
    public double Power(double base, int exponent) {
        long N = exponent;
        return exponent > 0 ? quickMul(base, N) : 1.0 / quickMul(base, -N);
    }
    private double quickMul(double base, long N) {
        double ans = 1.0;
        double temp = base;
        while(N > 0) {
            if(N % 2 == 1) {
                ans *= temp;
            }
            temp *= temp;
            N /= 2;
        }
        return ans;
    }
}   
```

------

### 第3题 调整数组顺序使奇数位于偶数前面

难度：中等

类型：数组

方法：遍历

#### a. 原题陈述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### b. 解题思路

首先遍历一次数组统计出原数组中奇数的个数，假定奇数个数为n个，创建一个原数组长度的新数组，再遍历一次原数组，如果当前值为奇数，则添加在新数组前面，偶数则添加在新数组n位之后。

#### c. 解题代码

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
        if(array==null || array.length==0){return new int[0];}
        int[] newArray = new int[array.length];
        // 统计奇数的个数
        int sum = 0;
        for(int i=0;i<array.length;i++){
            if(array[i]%2!=0){
                sum++;
            }
        }
        int a=0, b=sum;
        for(int i:array){
            if(i%2!=0){
                newArray[a++] = i;
            }else{
                newArray[sum++] = i;
            }
        }
        return newArray;
    }
}
```

#### d. 其他解法摘录

思路借鉴冒泡排序

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
        // bubble sort
        if (array == null || array.length == 0) return new int[0];
        int n = array.length; 
        
        for (int i=0; i<n; ++i) {
            for (int j=0; j<n-1-i; ++j) {
                // 左边是偶数, 右边是奇数的情况
                if ((array[j] & 1) == 0 && (array[j+1] & 1) == 1) {
                    int tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
        
        return array;
    }
}
```

------

### 第4题 链表中倒数第k个结点

难度：中等

类型：链表

#### a. 原题陈述

输入一个链表，输出该链表中倒数第k个结点。

如果该链表长度小于k，请返回空。

#### b. 解题思路

定义两个指针，假定要找到倒数第K个结点，则第一个指针从链表的头结点开始向前遍历k-1，第二个指针保持不动；而后从第k步开始，两个指针一同向前遍历整个链表，当第一个指针到达链表尾结点的时候，第二个指针正好是倒数第k个结点。

#### c. 解题代码

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode FindKthToTail (ListNode pHead, int k) {
        if(pHead==null){return null;}
        int count =0;
        ListNode first = pHead;
        ListNode second = pHead;
        for(int i=0;i<k;i++){
            if(first != null){
               first = first.next; 
                count +=1;
            }
        }
        if(count!=k){
            return null;
        }
        while(first != null){
            first = first.next;
            second = second.next;
        }
        return second;
        
    }
}
```

#### d. 其他解法摘录

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode FindKthToTail(ListNode pHead, int k) {
        int currentIndex = 0;
        ListNode first = pHead;
        ListNode second = pHead;

        if (pHead == null) {
            return null;
        }
        while (currentIndex < k && first != null ) {
            first = first.next;
            currentIndex++;
        }

        while (first != null) {
            first = first.next;
            second = second.next;
        }
        
        if (currentIndex < k) {
            return null;
        }
        return second;
    }
}     
```

------

### 第5题 反转链表

难度：中等

类型：链表

#### a. 原题陈述

输入一个链表，反转链表后，输出新链表的表头。

#### b.解题思路

定义两个指针，将待调整的结点的pNext指向前面一个结点，同时为了导致我们无法遍历链表中的下一个结点，我们需要在调整当前结点的pNext之前保存下一个结点。

#### c. 解题代码

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null){return null;}
        ListNode second=head.next;
        head.next=null;
        ListNode three=null;
        while(second!=null)
        {
            three=second.next;
            second.next=head;
            head=second;
            second=three;
        }
        return head;
    }
}
```

#### d. 其他解法摘录

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        // 迭代实现
//         ListNode prev = null;
//         ListNode curr = head;
//         while(curr != null) {
//             ListNode next = curr.next;
//             curr.next = prev;
//             prev = curr;
//             curr = next;
//         }
        
//         return prev;
        // 递归
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = ReverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
} 
```

------

