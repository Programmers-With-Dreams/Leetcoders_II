# 第三周_陈明虓

## 

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

#### 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

#### b. 解题思路

#### 分治

#### c. 解题代码

```java
class Solution {
    public class Struct {
           public int lSum;
           public int rSum;
           public int iSum;
           public int mSum;
           public Struct(int lSum, int rSum, int iSum, int mSum){
                  this.lSum = lSum;
                  this.rSum = rSum;
                  this.iSum = iSum;
                  this.mSum = mSum;
           } 
    }
    public int maxSubArray(int[] nums) {
           return fuction(nums, 0 ,nums.length - 1).mSum;
    }
    public Struct fuction(int[] nums, int l, int r){
           if (l == r)
              return new Struct(nums[l], nums[l], nums[l], nums[l]);
           int m = (l + r) / 2;
           Struct left = fuction(nums, l, m);
           Struct right = fuction(nums, m + 1, r);
           int lSum = Math.max(left.lSum, left.iSum + right.lSum);
           int rSum = Math.max(right.rSum, right.iSum + left.rSum);
           int iSum = left.iSum + right.iSum;
           int mSum = Math.max(left.rSum + right.lSum, Math.max(left.mSum, right.mSum));
           return new Struct(lSum, rSum, iSum, mSum); 
    }
}
```

#### 

#### d. 其他解法摘录

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}


```



------

### 

### 第2题

#### 

#### a. 原题陈述

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

#### b. 解题思路

分治

#### c. 解题代码

```
class Solution {
    public int longestSubstring(String s, int k) {
           return dfs(s, 0, s.length() - 1, k);
    }
    public int dfs(String str, int l, int r, int k){
           int[] nums = new int[26];
           for (int i = l ; i <= r ; i++){
               nums[str.charAt(i) - 'a']++;
           }
           int split = -1;
           for (int i = 0 ; i < 26 ; i++){
               if (nums[i] > 0 && nums[i] < k){
                  split = i;
                  break;
               }
           }
           if (split == -1)
              return r - l + 1;
           int start = l;
           int max = 0;
           for (int i = l ; i <= r ; i++){
               int len = 0;
               if (str.charAt(i) - 'a' == split){
                  if (start == i){
                     start = i + 1;
                     continue; 
                  }
                  len = dfs(str, start, i - 1, k);
                  start = i + 1;
               }
               else if (i == r) 
                  len = dfs(str, start, i, k);
               max = Math.max(max, len);
           }
           return max;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int longestSubstring(String s, int k) {
            int ret = 0;
            int n = s.length();
            for (int t = 1; t <= 26; t++) {
                int l = 0, r = 0;
                int[] cnt = new int[26];
                int tot = 0;
                int less = 0;
                while (r < n) {
                    cnt[s.charAt(r) - 'a']++;
                    if (cnt[s.charAt(r) - 'a'] == 1) {
                        tot++;
                        less++;
                    }
                    if (cnt[s.charAt(r) - 'a'] == k) {
                        less--;
                    }
    
                    while (tot > t) {
                        cnt[s.charAt(l) - 'a']--;
                        if (cnt[s.charAt(l) - 'a'] == k - 1) {
                            less++;
                        }
                        if (cnt[s.charAt(l) - 'a'] == 0) {
                            tot--;
                            less--;
                        }
                        l++;
                    }
                    if (less == 0) {
                        ret = Math.max(ret, r - l + 1);
                    }
                    r++;
                }
            }
            return ret;
        }
    }
    



------



### 第3题

#### 

#### a. 原题陈述

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

#### b. 解题思路

贪心算法

#### c. 解题代码

```
class Solution {
    public int maxProfit(int[] prices) {
           int ans = 0;
           for (int i = 0 ; i < prices.length - 1 ; i++){
               if (prices[i + 1] - prices[i] > 0)
               ans += prices[i + 1] - prices[i];
           }
           return ans;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int[][] dp = new int[n][2];
            dp[0][0] = 0;
            dp[0][1] = -prices[0];
            for (int i = 1; i < n; ++i) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[n - 1][0];
        }
    }
    
    



------



### 第4题

#### 

#### a. 原题陈述

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标

#### b. 解题思路

贪心算法

#### c. 解题代码

```
class Solution {
    public boolean canJump(int[] nums) { 
           int max = 0;
           boolean ans = true;
           for (int i = 0 ; i <= nums.length - 1 ; i++){
               if (i <= max){
                  max = Math.max(max, i + nums[i]);
               }
               else{
                  ans = false;
                  break;
               }
           }
           return ans;
    }
}
```

#### 

#### d. 其他解法摘录



    public class Solution {
        public boolean canJump(int[] nums) {
            int n = nums.length;
            int rightmost = 0;
            for (int i = 0; i < n; ++i) {
                if (i <= rightmost) {
                    rightmost = Math.max(rightmost, i + nums[i]);
                    if (rightmost >= n - 1) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    
    



------



### 第5题

#### 

#### a. 原题陈述

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）



#### b. 解题思路

贪心算法

#### c. 解题代码

```
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] person1, int[] person2) {
                if (person1[0] != person2[0]) {
                    return person2[0] - person1[0];
                } else {
                    return person1[1] - person2[1];
                }
            }
        });
        List<int[]> ans = new ArrayList<int[]>();
        for (int[] person : people) {
            ans.add(person[1], person);
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public int[][] reconstructQueue(int[][] people) {
            Arrays.sort(people, new Comparator<int[]>() {
                public int compare(int[] person1, int[] person2) {
                    if (person1[0] != person2[0]) {
                        return person1[0] - person2[0];
                    } else {
                        return person2[1] - person1[1];
                    }
                }
            });
            int n = people.length;
            int[][] ans = new int[n][];
            for (int[] person : people) {
                int spaces = person[1] + 1;
                for (int i = 0; i < n; ++i) {
                    if (ans[i] == null) {
                        --spaces;
                        if (spaces == 0) {
                            ans[i] = person;
                            break;
                        }
                    }
                }
            }
            return ans;
        }
    }
    


