# 第二周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   1    |   6    |        |

## II 本周刷题总结

### 第1题 [最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)

难度：中等

方法：dfs+bfs

#### a. 原题陈述

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）

#### b. 解题思路

1. dfs查找到一个岛屿，将岛屿0节点放入queue，1节点置2
2. queue逐层查找1，0节点置2并添加到新的一层

#### c. 解题代码

```java
class Solution {
    int[] direction = {-1, 0, 1, 0, -1};

    public int shortestBridge(int[][] A) {
        // 初始化
        Queue<List<Integer>> queue = new LinkedList<>();
        int m = A.length, n = A[0].length;
        boolean flipped = false;
        // dfs搜索第一个岛屿,将岛屿1置2,0 push进queue
        for(int i = 0; i < m; ++i){
            if(flipped) break;
            for(int j = 0; j < n; ++j){
                if(A[i][j]==1){
                    dfs(queue, A, m, n, i, j);
                    flipped = true;
                    break;
                }
            }
        }
        // bfs搜索最短路径,将0置2,收集下一层0
        int x, y, level = 0;
        while(!queue.isEmpty()){
            ++level;
            int n_points = queue.size();
            while(n_points-- != 0){
                List<Integer> list = queue.poll();
                for(int k = 0; k < 4; ++k){
                    x = direction[k] + list.get(0);
                    y = direction[k+1] + list.get(1);
                    if( x >= 0 && y >= 0 && x < m && y < n){
                        if(A[x][y] == 2)
                            continue;
                        if(A[x][y] == 1)
                            return level;
                        append(queue, x, y);
                        A[x][y] = 2;
                    }
                }
            }
        }
        // 返回值
        return 0;
    }
    // bfs找岛,构造queue
    private void dfs(Queue<List<Integer>> queue, int[][] A, int m, int n, int i, int j){
        if(i < 0 || j < 0 || i >= m || j >= n || A[i][j] == 2)
            return;
        if(A[i][j] == 0){
            // List<Integer> tmp = new LinkedList<>();
            // tmp.add(i);
            // tmp.add(j);
            // queue.offer(tmp);
            append(queue, i, j);
            return;
        }
        A[i][j] = 2;
        dfs(queue, A, m, n, i-1, j);
        dfs(queue, A, m, n, i+1, j);
        dfs(queue, A, m, n, i, j-1);
        dfs(queue, A, m, n, i, j+1);
    }
    // 辅助函数, 队列添加LinkedList
    private void append(Queue<List<Integer>> queue, int i, int j){
            List<Integer> tmp = new LinkedList<>();
            tmp.add(i);
            tmp.add(j);
            queue.offer(tmp);
    }
}
```

#### d. 其他解法摘录

大差不差版本

```java
    class Solution {
    private int[] direction = new int[]{-1,0,1,0,-1};
    private int res = 0;
    public int shortestBridge(int[][] A) {
        // 1. 先 dfs 将找到的第一座桥的值全部赋值为2，并将第一座桥旁边的 0 全部插入队列中
        // 2. 再 while 循环判断队列是否为空，循环体里会判断是否发现了第二座桥；
        Queue<int[]> queue = new LinkedList<>();
        // 先 dfs，将第一座岛上所有值都该为 2
        boolean dfsFlag = false; 
        for (int i = 0; i < A.length; i++) {
            if (dfsFlag) {
                break;
            }
            for (int j = 0; j < A[0].length; j++) {
                if (A[i][j] == 1) {
                    dfs(A, queue, i, j, A.length, A[0].length);
                    dfsFlag = true;
                    break;
                }
            }
        }

        // bfs 寻找下一座岛屿，遍历时将所有 0 值赋值为 2
        while (!queue.isEmpty()) {
            res++;
            int queueSize = queue.size();
            while (queueSize-- > 0) {
                int[] root = queue.poll();
                for (int i = 0; i < direction.length-1; i++) {
                    int x1 = root[0] + direction[i];
                    int y1 = root[1] + direction[i+1];
                    if (x1 >= 0 && x1 < A.length && y1 >= 0 && y1 < A[0].length) {
                        if (A[x1][y1] == 1) {
                            return res;
                        } else if (A[x1][y1] == 2) {
                            continue;
                        }
                        A[x1][y1] = 2;
                        queue.add(new int[]{x1,y1});
                    }
                }
            } 
        }
        return res;
    }

    private void dfs(int[][] A, Queue<int[]> queue, int x, int y, int n, int m) {
        // 插入所有为 0 的值的坐标到队列中
        // 为 1 的值就改变为 2 并且继续遍历四个方向
        // 为 2 的值就直接退出
        if (x < 0 || x == n || y < 0 || y == m || A[x][y] == 2) {
            return;
        }
        if (A[x][y] == 0) {
            queue.add(new int[]{x,y});
            return;
        }
        A[x][y] = 2;
        for (int i = 0; i < direction.length-1; i++) {
            int x1 = x + direction[i];
            int y1 = y + direction[i+1];
            dfs(A, queue, x1, y1, n, m);
        }
    }
}
```

------

### 第2题 [单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)

难度：困难

方法：万物皆可搜索

#### a. 原题陈述

给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：

每次转换只能改变一个字母。
转换后得到的单词必须是字典中的单词。
说明:

如果不存在这样的转换序列，返回一个空列表。
所有单词具有相同的长度。
所有单词只由小写字母组成。
字典中不存在重复的单词。
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

#### b. 解题思路



#### c. 解题代码

```java
// 1. dfs
class Solution {
    int min = Integer.MAX_VALUE;

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        ArrayList<String> temp = new ArrayList<>();// 保存当前路径
        temp.add(beginWord);
        findLaddersHelper(beginWord, endWord, wordList, temp, ans);
        return ans;
    }
    private void findLaddersHelper(String beginWord, String endWord, List<String> wordList, ArrayList<String> temp, List<List<String>> ans){
        if(beginWord.equals(endWord)){
            if(min > temp.size()){
                ans.clear();
                min = temp.size();
                ans.add(new ArrayList<String>(temp));//ans中存着满足最小条件的所有List<String>
            }else if(min == temp.size()){
                ans.add(new ArrayList<String>(temp));
            }
            return;
        }
        if(temp.size() > min){
            return;
        }
        Set<String> dict = new HashSet<>(wordList);
        ArrayList<String> neighbors = getNeighbors(beginWord, dict);// 一次性到达所有的下一个节点
        for(String neighbor : neighbors){
            if(temp.contains(neighbor)){
                continue;
            }
            temp.add(neighbor);
            findLaddersHelper(neighbor, endWord, wordList, temp, ans);// 回溯算法判定路线
            temp.remove(temp.size()-1);
        }
    }
    // 获得当前node的下一群node
    private ArrayList<String> getNeighbors(String node, Set<String> dict){
        ArrayList<String> res = new ArrayList<>();
        char[] chs = node.toCharArray();

        for(char ch = 'a'; ch <= 'z'; ++ch){
            for(int i = 0; i < chs.length; ++i){
                if(chs[i] == ch){
                    continue;
                }
                char old_ch = chs[i];
                chs[i] = ch;
                chs[i] = ch;
                if(dict.contains(String.valueOf(chs))){
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }
        }
        return res;
    }
}

------------------------------
------------------------------
    
class Solution {
    int min = 0;

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        if(!wordList.contains(endWord)){
            return ans;
        }
        // 利用bfs获得所有邻居节点
        HashMap<String, ArrayList<String>> map = bfs(beginWord, endWord, wordList);// 与前一版本相比的区别正在于此
        ArrayList<String> temp = new ArrayList<>();// 保存当前路径
        temp.add(beginWord);
        findLaddersHelper(beginWord, endWord, map, temp, ans);
        return ans;
    }
    private void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map, ArrayList<String> temp, List<List<String>> ans){
        if(beginWord.equals(endWord)){
            ans.add(new ArrayList<String>(temp));//ans中存着满足最小条件的所有List<String>
            return;
        }
        if(temp.size()-1 == min){
            return;
        }
        // Set<String> dict = new HashSet<>(wordList);
        ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());// 一次性到达所有的下一个节点
        for(String neighbor : neighbors){
            if(temp.contains(neighbor)){
                continue;
            }
            temp.add(neighbor);
            findLaddersHelper(neighbor, endWord, map, temp, ans);// 回溯算法判定路线
            temp.remove(temp.size()-1);
        }
    }
    private HashMap<String, ArrayList<String>> bfs(String beginWord, String endWord, List<String> wordList){
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        HashMap<String, ArrayList<String>> map = new HashMap<>();
        boolean isFound = false;

        Set<String> dict = new HashSet<>(wordList);
        while(!queue.isEmpty()){
            int size = queue.size();
            min++;// 一层一层地遍历
            for(int j = 0; j < size; ++j){
                String temp = queue.poll();
                ArrayList<String> neighbors = getNeighbors(temp, dict);
                map.put(temp, neighbors);
                for (String neighbor : neighbors) {
                if (neighbor.equals(endWord)) {
                    isFound = true;
                }
                queue.offer(neighbor);
            }
            if (isFound)
                break;
            }
        }
        return map;
    }
    // 获得当前node的下一群node
    private ArrayList<String> getNeighbors(String node, Set<String> dict){
        ArrayList<String> res = new ArrayList<>();
        char[] chs = node.toCharArray();

        for(char ch = 'a'; ch <= 'z'; ++ch){
            for(int i = 0; i < chs.length; ++i){
                if(chs[i] == ch){
                    continue;
                }
                char old_ch = chs[i];
                chs[i] = ch;
                chs[i] = ch;
                if(dict.contains(String.valueOf(chs))){
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }
        }
        return res;
    }
}
---------------------------
---------------------------
    class Solution {

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        if(!wordList.contains(endWord)){
            return ans;
        }
        // 利用bfs获得所有邻居节点
        HashMap<String, Integer> distance = new HashMap<>();
        HashMap<String, ArrayList<String>> map = new HashMap<>();
        bfs(beginWord, endWord, wordList, map, distance);// 与前一版本相比的区别正在于此
        ArrayList<String> temp = new ArrayList<>();// 保存当前路径
        temp.add(beginWord);
        findLaddersHelper(beginWord, endWord, map, distance, temp, ans);
        return ans;
    }
    private void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map, HashMap<String, Integer> distance, ArrayList<String> temp, List<List<String>> ans){
        if(beginWord.equals(endWord)){
            ans.add(new ArrayList<String>(temp));//ans中存着满足最小条件的所有List<String>
            return;
        }
        // if(temp.size()-1 == min){
        //     return;
        // }
        
        ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());// 一次性到达所有的下一个节点
        for(String neighbor : neighbors){
            // if(temp.contains(neighbor)){// 其他路径已经考虑过的单词，此处也可以跳过
            //     continue;
            // }
            if(distance.get(beginWord)+1 == distance.get(neighbor)){// 判断层数是否符合
                temp.add(neighbor);
                findLaddersHelper(neighbor, endWord, map, distance, temp, ans);// 回溯算法判定路线
                temp.remove(temp.size()-1);
            }
        }
    }
    private void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map,HashMap<String, Integer> distance){
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        distance.put(beginWord, 0);
        boolean isFound = false;
        int depth = 0;
        Set<String> dict = new HashSet<>(wordList);
        while(!queue.isEmpty()){
            int size = queue.size();
            depth++;// 一层一层地遍历
            for(int j = 0; j < size; ++j){
                String temp = queue.poll();
                ArrayList<String> neighbors = getNeighbors(temp, dict);
                map.put(temp, neighbors);
                for (String neighbor : neighbors) {
                    // if (neighbor.equals(endWord)) {
                    //     isFound = true;
                    if(!distance.containsKey(neighbor)){
                        distance.put(neighbor, depth);
                        if(neighbor.equals(endWord)){
                            isFound = true;
                        }
                        queue.offer(neighbor);
                    }
                }
                
            }
            if (isFound){
                break;
            }
        }
    }
    // 获得当前node的下一群node
    private ArrayList<String> getNeighbors(String node, Set<String> dict){
        ArrayList<String> res = new ArrayList<>();
        char[] chs = node.toCharArray();

        for(char ch = 'a'; ch <= 'z'; ++ch){
            for(int i = 0; i < chs.length; ++i){
                if(chs[i] == ch){
                    continue;
                }
                char old_ch = chs[i];
                chs[i] = ch;
                if(dict.contains(String.valueOf(chs))){
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }
        }
        return res;
    }
}


------------------------
------------------------
class Solution {

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        if (!wordList.contains(endWord)) {
            return ans;
        }
        // 利用 BFS 得到所有的邻居节点
        HashMap<String, ArrayList<String>> map = new HashMap<>();
        bfs(beginWord, endWord, wordList, map);
        ArrayList<String> temp = new ArrayList<String>();
        // temp 用来保存当前的路径
        temp.add(beginWord);
        findLaddersHelper(beginWord, endWord, map, temp, ans);
        return ans;
    }

    private void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,
                                ArrayList<String> temp, List<List<String>> ans) {
        if (beginWord.equals(endWord)) {
            ans.add(new ArrayList<String>(temp));
            return;
        }
        // 得到所有的下一个的节点
        ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());
        for (String neighbor : neighbors) {
            temp.add(neighbor);
            findLaddersHelper(neighbor, endWord, map, temp, ans);
            temp.remove(temp.size() - 1);

        }
    }

    public void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map) {
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        boolean isFound = false;
        int depth = 0;
        Set<String> dict = new HashSet<>(wordList);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        while (!queue.isEmpty()) {
            int size = queue.size();
            depth++;
            Set<String> subVisited = new HashSet<>();
            for (int j = 0; j < size; j++) {
                String temp = queue.poll();
                // 一次性得到所有的下一个的节点
                ArrayList<String> neighbors = getNeighbors(temp, dict); 
                Iterator<String> it = neighbors.iterator();//把元素导入迭代器
                while (it.hasNext()) {
                    String neighbor = it.next();
                    if (!visited.contains(neighbor)) {
                        if (neighbor.equals(endWord)) {
                            isFound = true;
                        }
                        queue.offer(neighbor);
                        subVisited.add(neighbor);
                    }else{
                        it.remove();// 删除访问过的
                    } 
                }
                map.put(temp, neighbors);
            }
            visited.addAll(subVisited);
            if (isFound) {
                break;
            }
        }
    }

    private ArrayList<String> getNeighbors(String node, Set<String> dict) {
        ArrayList<String> res = new ArrayList<String>();
        char chs[] = node.toCharArray();

        for (char ch = 'a'; ch <= 'z'; ch++) {
            for (int i = 0; i < chs.length; i++) {
                if (chs[i] == ch)
                    continue;
                char old_ch = chs[i];
                chs[i] = ch;
                if (dict.contains(String.valueOf(chs))) {
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }

        }
        return res;
    }
}


------------------------
------------------------
// BFS Not AC  
    class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        // 如果不含有结束单词，直接结束，不然后边会造成死循环
        if (!wordList.contains(endWord)) {
            return ans;
        }
        bfs(beginWord, endWord, wordList, ans);// 深度优先搜索
        return ans;
    }

    public void bfs(String beginWord, String endWord, List<String> wordList, List<List<String>> ans) {
        Queue<List<String>> queue = new LinkedList<>();// 深度优先搜索辅助队列
        List<String> path = new ArrayList<>();// 路径
        path.add(beginWord);
        queue.offer(path);// 
        boolean isFound = false;
        Set<String> dict = new HashSet<>(wordList);// 单词集合
        Set<String> visited = new HashSet<>();// 访问过的单词集合
        visited.add(beginWord);
        while (!queue.isEmpty()) {
            int size = queue.size();
            Set<String> subVisited = new HashSet<>();
            for (int j = 0; j < size; j++) {
                List<String> p = queue.poll();// 得到List<String>
                //得到当前路径的末尾单词
                String temp = p.get(p.size() - 1);
                // 一次性得到所有的下一个的节点
                ArrayList<String> neighbors = getNeighbors(temp, dict);
                for (String neighbor : neighbors) {
                    //只考虑之前没有出现过的单词
                    if (!visited.contains(neighbor)) {
                        //到达结束单词
                        if (neighbor.equals(endWord)) {
                            isFound = true;
                            p.add(neighbor);
                            ans.add(new ArrayList<String>(p));// 直接添加路径咧
                            p.remove(p.size() - 1);
                        }
                        //加入当前单词
                        p.add(neighbor);
                        queue.offer(new ArrayList<String>(p));
                        p.remove(p.size() - 1);
                        subVisited.add(neighbor);
                    }
                }
            }
            visited.addAll(subVisited);
            if (isFound) {
                break;
            }
        }
    }

    private ArrayList<String> getNeighbors(String node, Set<String> dict) {
        ArrayList<String> res = new ArrayList<String>();
        char chs[] = node.toCharArray();
        for (char ch = 'a'; ch <= 'z'; ch++) {
            for (int i = 0; i < chs.length; i++) {
                if (chs[i] == ch)
                    continue;
                char old_ch = chs[i];
                chs[i] = ch;
                if (dict.contains(String.valueOf(chs))) {
                    res.add(String.valueOf(chs));
                }
                chs[i] = old_ch;
            }

        }
        return res;
    }

}

-------------------------
-------------------------
// BFS+DFS

```

#### d. 其他解法摘录

two-end DFS

```java
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> ans = new ArrayList<>();
        if (!wordList.contains(endWord)) {
            return ans;
        }
        // 利用 BFS 得到所有的邻居节点
        HashMap<String, ArrayList<String>> map = new HashMap<>();
        bfs(beginWord, endWord, wordList, map);
        ArrayList<String> temp = new ArrayList<String>();
        // temp 用来保存当前的路径
        temp.add(beginWord);
        findLaddersHelper(beginWord, endWord, map, temp, ans);
        return ans;
    }

    private void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,
                                ArrayList<String> temp, List<List<String>> ans) {
        if (beginWord.equals(endWord)) {
            ans.add(new ArrayList<String>(temp));
            return;
        }
        // 得到所有的下一个的节点
        ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());
        for (String neighbor : neighbors) {
            temp.add(neighbor);
            findLaddersHelper(neighbor, endWord, map, temp, ans);
            temp.remove(temp.size() - 1);
        }
    }

    //利用递归实现了双向搜索
    private void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map) {
        Set<String> set1 = new HashSet<String>();
        set1.add(beginWord);
        Set<String> set2 = new HashSet<String>();
        set2.add(endWord);
        Set<String> wordSet = new HashSet<String>(wordList);
        bfsHelper(set1, set2, wordSet, true, map);
    }

    // direction 为 true 代表向下扩展，false 代表向上扩展
    private boolean bfsHelper(Set<String> set1, Set<String> set2, Set<String> wordSet, boolean direction,
                            HashMap<String, ArrayList<String>> map) {
        //set1 为空了，就直接结束
        //比如下边的例子就会造成 set1 为空
        /*	"hot"
            "dog"
            ["hot","dog"]*/
        if(set1.isEmpty()){
            return false;
        }
        // set1 的数量多，就反向扩展
        if (set1.size() > set2.size()) {
            return bfsHelper(set2, set1, wordSet, !direction, map);
        }
        // 将已经访问过单词删除
        wordSet.removeAll(set1);
        wordSet.removeAll(set2);

        boolean done = false;

        // 保存新扩展得到的节点
        Set<String> set = new HashSet<String>();

        for (String str : set1) {
            //遍历每一位
            for (int i = 0; i < str.length(); i++) {
                char[] chars = str.toCharArray();

                // 尝试所有字母
                for (char ch = 'a'; ch <= 'z'; ch++) {
                    if(chars[i] == ch){
                        continue;
                    }
                    chars[i] = ch;

                    String word = new String(chars);

                    // 根据方向得到 map 的 key 和 val
                    String key = direction ? str : word;
                    String val = direction ? word : str;

                    ArrayList<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();
                    
                    //如果相遇了就保存结果
                    if (set2.contains(word)) {
                        done = true;
                        list.add(val);
                        map.put(key, list);
                    }

                    //如果还没有相遇，并且新的单词在 word 中，那么就加到 set 中
                    if (!done && wordSet.contains(word)) {
                        set.add(word);
                        list.add(val);
                        map.put(key, list);
                    }
                }
            }
        }

        //一般情况下新扩展的元素会多一些，所以我们下次反方向扩展  set2
        return done || bfsHelper(set2, set, wordSet, !direction, map);

    }
}
```

------

### 第3题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第4题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第5题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第6题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

