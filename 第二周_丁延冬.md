# 第二周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   1    |   6    |        |

## II 本周刷题总结

### 第1题 [最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)

难度：中等

方法：dfs+bfs

#### a. 原题陈述

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）

#### b. 解题思路

1. dfs查找到一个岛屿，将岛屿0节点放入queue，1节点置2
2. queue逐层查找1，0节点置2并添加到新的一层

#### c. 解题代码

```java
class Solution {
    int[] direction = {-1, 0, 1, 0, -1};

    public int shortestBridge(int[][] A) {
        // 初始化
        Queue<List<Integer>> queue = new LinkedList<>();
        int m = A.length, n = A[0].length;
        boolean flipped = false;
        // dfs搜索第一个岛屿,将岛屿1置2,0 push进queue
        for(int i = 0; i < m; ++i){
            if(flipped) break;
            for(int j = 0; j < n; ++j){
                if(A[i][j]==1){
                    dfs(queue, A, m, n, i, j);
                    flipped = true;
                    break;
                }
            }
        }
        // bfs搜索最短路径,将0置2,收集下一层0
        int x, y, level = 0;
        while(!queue.isEmpty()){
            ++level;
            int n_points = queue.size();
            while(n_points-- != 0){
                List<Integer> list = queue.poll();
                for(int k = 0; k < 4; ++k){
                    x = direction[k] + list.get(0);
                    y = direction[k+1] + list.get(1);
                    if( x >= 0 && y >= 0 && x < m && y < n){
                        if(A[x][y] == 2)
                            continue;
                        if(A[x][y] == 1)
                            return level;
                        append(queue, x, y);
                        A[x][y] = 2;
                    }
                }
            }
        }
        // 返回值
        return 0;
    }
    // bfs找岛,构造queue
    private void dfs(Queue<List<Integer>> queue, int[][] A, int m, int n, int i, int j){
        if(i < 0 || j < 0 || i >= m || j >= n || A[i][j] == 2)
            return;
        if(A[i][j] == 0){
            // List<Integer> tmp = new LinkedList<>();
            // tmp.add(i);
            // tmp.add(j);
            // queue.offer(tmp);
            append(queue, i, j);
            return;
        }
        A[i][j] = 2;
        dfs(queue, A, m, n, i-1, j);
        dfs(queue, A, m, n, i+1, j);
        dfs(queue, A, m, n, i, j-1);
        dfs(queue, A, m, n, i, j+1);
    }
    // 辅助函数, 队列添加LinkedList
    private void append(Queue<List<Integer>> queue, int i, int j){
            List<Integer> tmp = new LinkedList<>();
            tmp.add(i);
            tmp.add(j);
            queue.offer(tmp);
    }
}
```

#### d. 其他解法摘录

大差不差版本

```java
    class Solution {
    private int[] direction = new int[]{-1,0,1,0,-1};
    private int res = 0;
    public int shortestBridge(int[][] A) {
        // 1. 先 dfs 将找到的第一座桥的值全部赋值为2，并将第一座桥旁边的 0 全部插入队列中
        // 2. 再 while 循环判断队列是否为空，循环体里会判断是否发现了第二座桥；
        Queue<int[]> queue = new LinkedList<>();
        // 先 dfs，将第一座岛上所有值都该为 2
        boolean dfsFlag = false; 
        for (int i = 0; i < A.length; i++) {
            if (dfsFlag) {
                break;
            }
            for (int j = 0; j < A[0].length; j++) {
                if (A[i][j] == 1) {
                    dfs(A, queue, i, j, A.length, A[0].length);
                    dfsFlag = true;
                    break;
                }
            }
        }

        // bfs 寻找下一座岛屿，遍历时将所有 0 值赋值为 2
        while (!queue.isEmpty()) {
            res++;
            int queueSize = queue.size();
            while (queueSize-- > 0) {
                int[] root = queue.poll();
                for (int i = 0; i < direction.length-1; i++) {
                    int x1 = root[0] + direction[i];
                    int y1 = root[1] + direction[i+1];
                    if (x1 >= 0 && x1 < A.length && y1 >= 0 && y1 < A[0].length) {
                        if (A[x1][y1] == 1) {
                            return res;
                        } else if (A[x1][y1] == 2) {
                            continue;
                        }
                        A[x1][y1] = 2;
                        queue.add(new int[]{x1,y1});
                    }
                }
            } 
        }
        return res;
    }

    private void dfs(int[][] A, Queue<int[]> queue, int x, int y, int n, int m) {
        // 插入所有为 0 的值的坐标到队列中
        // 为 1 的值就改变为 2 并且继续遍历四个方向
        // 为 2 的值就直接退出
        if (x < 0 || x == n || y < 0 || y == m || A[x][y] == 2) {
            return;
        }
        if (A[x][y] == 0) {
            queue.add(new int[]{x,y});
            return;
        }
        A[x][y] = 2;
        for (int i = 0; i < direction.length-1; i++) {
            int x1 = x + direction[i];
            int y1 = y + direction[i+1];
            dfs(A, queue, x1, y1, n, m);
        }
    }
}
```

------

### 第2题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第4题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第5题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

### 第6题 

难度：

方法：

#### a. 原题陈述

```

```

#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java
    
```

------

