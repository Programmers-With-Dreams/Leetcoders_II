# 第五周_陈明虓

##  

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| ------ | ------ | ------ |
| 5      | 5      | 100%   |

## 

## II 本周刷题总结

### 

### 第1题

#### 

#### a. 原题陈述

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。



#### b. 解题思路

#### dp

#### c. 解题代码

```java
class Solution {
    public int jump(int[] nums) {
           int  n = nums.length;
           int[][] dp = new int[n + 1][n + 1];
           if (n == 1)
              return 0;
           for (int i = 2 ; i <= n ; i++){
               for (int j = i - 1 ; j >= 1 ; j--){
                   if (i - j == 1 || nums[j - 1] >= i - j){
                      if (nums[j - 1]  == 0){
                         dp[j][i] = n;//不可到达就把跳跃数设的很大
                         continue;
                      } 
                      else {
                         dp[j][i] = 1;
                         continue;
                      }
                   }   
                   else {                              
                        int min = n;
                        for (int k = j + 1 ; k <= i - 1 ; k++){
                        min = Math.min(min, dp[j][k] + dp[k][i]); 
                        }
                       dp[j][i] = min;
                   }
               }
           }
          return dp[1][n] >= n ? -1 : dp[1][n];
    }
}
```

#### 

#### d. 其他解法摘录

```java
class Solution {
    public int jump(int[] nums) {
        int position = nums.length - 1;
        int steps = 0;
        while (position > 0) {
            for (int i = 0; i < position; i++) {
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
}

```



------

### 

### 第2题

#### 

#### a. 原题陈述

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 



#### b. 解题思路

dp

#### c. 解题代码

```
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        if (n >= 2)
           dp[2] = 2;
        for (int i = 3 ; i <= n ; i++){
            if (Math.sqrt(i)-(int)Math.sqrt(i) == 0){
               dp[i] = 1;
               continue;
            }
            int min = Integer.MAX_VALUE;
            for (int j = 1 ; j <= i / 2 ; j++){
                min = Math.min(min, dp[j] + dp[i - j]);
            }
            dp[i] = min;
        }
        return dp[n];
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
    
      public int numSquares(int n) {
        int dp[] = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        // bottom case
        dp[0] = 0;
    
        // pre-calculate the square numbers.
        int max_square_index = (int) Math.sqrt(n) + 1;
        int square_nums[] = new int[max_square_index];
        for (int i = 1; i < max_square_index; ++i) {
          square_nums[i] = i * i;
        }
    
        for (int i = 1; i <= n; ++i) {
          for (int s = 1; s < max_square_index; ++s) {
            if (i < square_nums[s])
              break;
            dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);
          }
        }
        return dp[n];
      }
    }



------



### 第3题

#### 

#### a. 原题陈述

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。



#### b. 解题思路

数组

#### c. 解题代码

```
class Solution {
    public int majorityElement(int[] nums) {
          
         int a=0, n=0, s=0, ans=0; 
         List<Integer> check = new ArrayList<Integer>();
         int length = nums.length;
         for (int i = 0 ; i <= length-1 ; i++){
             if (check.contains(nums[i])){
                 continue;
             }
             a = nums[i];
             check.add(a);
             for (int j = i ; j <= length-1 ; j++){
                 if (a == nums[j] ){
                     n++;
                 }  
            }
             if (n > s){
                s = n;
                n = 0;
                ans = a;
             }  
         }
      return ans;
    }
}
```

#### 

#### d. 其他解法摘录



    class Solution {
        private Map<Integer, Integer> countNums(int[] nums) {
            Map<Integer, Integer> counts = new HashMap<Integer, Integer>();
            for (int num : nums) {
                if (!counts.containsKey(num)) {
                    counts.put(num, 1);
                } else {
                    counts.put(num, counts.get(num) + 1);
                }
            }
            return counts;
        }
    
        public int majorityElement(int[] nums) {
            Map<Integer, Integer> counts = countNums(nums);
    
            Map.Entry<Integer, Integer> majorityEntry = null;
            for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
                if (majorityEntry == null || entry.getValue() > majorityEntry.getValue()) {
                    majorityEntry = entry;
                }
            }
    
            return majorityEntry.getKey();
        }
    }



​    



------



### 第4题

#### 

#### a. 原题陈述

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。



#### b. 解题思路

数组

#### c. 解题代码

```
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    ArrayList<Integer> a = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) { 
           dfs(0, nums);
           return ans;
    }        
    public void dfs(int start, int[] nums){
           ArrayList<Integer> b = (ArrayList<Integer>)a.clone();
           ans.add(b);       
           for (int i = start ; i <= nums.length - 1 ; i++){
               a.add(nums[i]);
               dfs(i+1, nums);
               a.remove(a.size()-1);
           }
    }
}
```

#### 

#### d. 其他解法摘录

回溯

    import java.util.ArrayList;
    import java.util.List;
    
    
    public class Solution {
    
        private List<List<Integer>> res;
    
        private void find(int[] nums, int begin, List<Integer> pre) {
            // 没有显式的递归终止
            res.add(new ArrayList<>(pre));// 注意：Java 的引用传递机制，这里要 new 一下
            for (int i = begin; i < nums.length; i++) {
                pre.add(nums[i]);
                find(nums, i + 1, pre);
                pre.remove(pre.size() - 1);// 组合问题，状态在递归完成后要重置
            }
        }
    
        public List<List<Integer>> subsets(int[] nums) {
            int len = nums.length;
            res = new ArrayList<>();
            if (len == 0) {
                return res;
            }
            List<Integer> pre = new ArrayList<>();
            find(nums, 0, pre);
            return res;
        }
    }
    



​    



------



### 第5题

#### 

#### a. 原题陈述

给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。

字符串 ***t\*** 由字符串 ***s\*** 随机重排，然后在随机位置添加一个字母。

请找出在 ***t*** 中被添加的字母



#### b. 解题思路

字符串

#### c. 解题代码

```
class Solution {
    public char findTheDifference(String s, String t) {
           Map<Character,Integer> map1 = new HashMap<Character,Integer>();
           Map<Character,Integer> map2 = new HashMap<Character,Integer>();
           for (int i = 0 ; i < s.length() ; i++){
               int val = 1;
               if (map1.containsKey(s.charAt(i))){
                  val = map1.get(s.charAt(i)) + 1;
               }
               map1.put(s.charAt(i), val) ;
           } 
             for (int i = 0 ; i < t.length() ; i++){
               int val = 1;
               char cur = t.charAt(i);  //防止越界!!!
               if (map2.containsKey(t.charAt(i))){ 
                  val = map2.get(t.charAt(i)) + 1;
                  if (val > map1.get(cur))
                  return (char)t.charAt(i);
               }
               if (!map1.containsKey(t.charAt(i))){
                  return (char)t.charAt(i);
               }
               map2.put(t.charAt(i), val);
           } 
           return t.charAt(0);     
    }
}
```

#### 

#### d. 其他解法摘录

    class Solution {
        public char findTheDifference(String s, String t) {
            int ret = 0;
            for (int i = 0; i < s.length(); ++i) {
                ret ^= s.charAt(i);
            }
            for (int i = 0; i < t.length(); ++i) {
                ret ^= t.charAt(i);
            }
            return (char) ret;
        }
    }




