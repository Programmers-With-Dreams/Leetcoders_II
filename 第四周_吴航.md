# 第四周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   7    |   7    |  100%  |

## II 本周刷题总结

### 第1题 [在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

难度：中等

方法：二分法

#### a. 原题陈述

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

#### b. 解题思路

![image-20210502153831349](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502153831349.png)

![image-20210502154054140](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502154054140.png)

![image-20210502154433151](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502154433151.png)

#### c. 解题代码

```java
class Solution {
    public int shipWithinDays(int[] weights, int D) {
        //左边界
        int left = weights[0];
        
        for(int w : weights){
            if(left < w){
                left = w;
            }
        }
        //右边界
        int right = left*weights.length/D + 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            int cur = 0;
            int need = 1;
            for(int weight : weights){
                if(cur + weight > mid){
                    need++;
                    cur = 0;
                }
                cur += weight;
            }
            if(need <= D){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return right;
    }
```

#### d. 其他解法摘录

```java
    
```

------

### 第2题 [二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

难度：简单

方法：递归

#### a. 原题陈述

给定二叉搜索树的根结点 `root`，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。

#### b. 解题思路

![image-20210502154842766](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502154842766.png)

#### c. 解题代码

```java
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if (root == null) {
            return 0;
        }
        if (root.val > high) {
            return rangeSumBST(root.left, low, high);
        }
        if (root.val < low) {
            return rangeSumBST(root.right, low, high);
        }
        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

难度：中等

方法：双指针

#### a. 原题陈述

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。

#### b. 解题思路

![](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502155119701.png)

![image-20210502155439276](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502155439276.png)

![image-20210502155536119](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502155536119.png)

#### c. 解题代码

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long left = 0;
        long right = (long) Math.sqrt(c);
        while (left <= right) {
            long sum = left * left + right * right;
            if (sum == c) {
                return true;
            } else if (sum > c) {
                right--;
            } else {
                left++;
            }
        }
        return false;
    }
}
```

#### d. 其他解法摘录

```java
使用sqrt函数
class Solution {
    public boolean judgeSquareSum(int c) {
        for (long a = 0; a * a <= c; a++) {
            double b = Math.sqrt(c - a * a);
            if (b == (int) b) {
                return true;
            }
        }
        return false;
    }
}
```

------

### 第4题 [青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

难度：困难

方法：动态规划

#### a. 原题陈述

一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。

开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

#### b. 解题思路

![image-20210502155845273](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502155845273.png)

#### c. 解题代码

```java
class Solution {
    public boolean canCross(int[] stones) {
        int n = stones.length;
        boolean[][] dp = new boolean[n][n];
        dp[0][0] = true;
        for (int i = 1; i < n; ++i) {
            if (stones[i] - stones[i - 1] > i) {
                return false;
            }
        }
        for (int i = 1; i < n; ++i) {
            for (int j = i - 1; j >= 0; --j) {
                int k = stones[i] - stones[j];
                if (k > j + 1) {
                    break;
                }
                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
                if (i == n - 1 && dp[i][k]) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

#### d. 其他解法摘录

![image-20210502160008915](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502160008915.png)

```java
class Solution {
    private Boolean[][] rec;

    public boolean canCross(int[] stones) {
        int n = stones.length;
        rec = new Boolean[n][n];
        return dfs(stones, 0, 0);
    }

    private boolean dfs(int[] stones, int i, int lastDis) {
        if (i == stones.length - 1) {
            return true;
        }
        if (rec[i][lastDis] != null) {
            return rec[i][lastDis];
        }

        for (int curDis = lastDis - 1; curDis <= lastDis + 1; curDis++) {
            if (curDis > 0) {
                int j = Arrays.binarySearch(stones, i + 1, stones.length, curDis + stones[i]);
                if (j >= 0 && dfs(stones, j, curDis)) {
                    return rec[i][lastDis] = true;
                }
            }
        }
        return rec[i][lastDis] = false;
    }
}
```

------

### 第5题 [只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

难度：中等

#### a. 原题陈述

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

#### b. 解题思路

排序之后查找

#### c. 解题代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 1; i += 3){
            if(nums[i] != nums[i+1]){
                return nums[i];
            }
        }
        return nums[nums.length - 1];
    }
}
```

#### d. 其他解法摘录

![image-20210502160420802](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502160420802.png)

```
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

![image-20210502160519765](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502160519765.png)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}
```

------

### 第6题 [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度：简单

方法：递归

#### a. 原题陈述

给定二叉搜索树的根结点 `root`，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。

#### b. 解题思路

![image-20210502160935478](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502160935478.png)

#### c. 解题代码

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第7题 [砖墙](https://leetcode-cn.com/problems/brick-wall/)

难度：中等

方法：哈希表

#### a. 原题陈述

给定二叉搜索树的根结点 `root`，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。

#### b. 解题思路

![image-20210502161102829](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210502161102829.png)

#### c. 解题代码

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for(List<Integer> width : wall){
            int n = width.size();
            int sum = 0;
            for(int i = 0; i < n - 1; i++){
                sum += width.get(i);
                cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
            }
        } 
        int maxCnt = 0;
        for(Map.Entry<Integer, Integer> entry : cnt.entrySet()){
            maxCnt = Math.max(maxCnt, entry.getValue());
        }
        return wall.size() - maxCnt;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 

### ### 