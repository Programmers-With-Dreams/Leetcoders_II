第八周_吴航

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   7    |   7    |  100%  |

## II 本周刷题总结

### 第1题 [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

难度：简单

#### a. 原题陈述

![image-20210530105704447](C:\Users\xiaohuahua\AppData\Roaming\Typora\typora-user-images\image-20210530105704447.png)

#### b. 解题思路

![image-20210530105921736](https://i.loli.net/2021/05/30/TdAzN1ku2s9SgjX.png)

#### c. 解题代码

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
			return 0;
		}

		int left = minDepth(root.left);
		int right = minDepth(root.right);
		return left == 0 || right == 0 ? 1 + left + right : 1 + Math.min(left, right);
    }
}
```

#### d. 其他解法摘录

![image-20210530110108130](https://i.loli.net/2021/05/30/3IAYjwoyGDOzsLE.png)

```java
迭代
class Solution {
    class QueueNode {
        TreeNode node;
        int depth;

        public QueueNode(TreeNode node, int depth) {
            this.node = node;
            this.depth = depth;
        }
    }

    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue<QueueNode> queue = new LinkedList<QueueNode>();
        queue.offer(new QueueNode(root, 1));
        while (!queue.isEmpty()) {
            QueueNode nodeDepth = queue.poll();
            TreeNode node = nodeDepth.node;
            int depth = nodeDepth.depth;
            if (node.left == null && node.right == null) {
                return depth;
            }
            if (node.left != null) {
                queue.offer(new QueueNode(node.left, depth + 1));
            }
            if (node.right != null) {
                queue.offer(new QueueNode(node.right, depth + 1));
            }
        }

        return 0;
    }
}
```

------

### 第2题 [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

难度：简单

方法：递归，迭代，morris三种方法

#### a. 原题陈述

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

#### b. 解题思路

递归

迭代

morris

![image-20210530111348480](https://i.loli.net/2021/05/30/QJB86uFDisq1CE9.png)



#### c. 解题代码

```java
递归
    class Solution {
    List<Integer> ans = new ArrayList<Integer>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null){
            return ans;
        }

        ans.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return ans;
    }
}
迭代
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        if(root == null){
            return ans;
        }
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while(!stack.isEmpty() || node != null){
            while(node != null){
                ans.add(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return ans;
    }
}
morris
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    res.add(p1.val);
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                }
            } else {
                res.add(p1.val);
            }
            p1 = p1.right;
        }
        return res;
    }
}
```

#### d. 其他解法摘录

```java
    
```

------

### 第3题 [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度：简单

方法：迭代，递归

#### a. 原题陈述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

#### b. 解题思路

迭代

![image-20210530111608514](https://i.loli.net/2021/05/30/SZAQTWUFt57hqxl.png)

#### c. 解题代码

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

#### d. 其他解法摘录

递归

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

------

### 第4题 [反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

难度：中等

#### a. 原题陈述

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

#### b. 解题思路

用栈，判断左括号，把上一层字符串加入到栈中，判断右括号，反转当前字符串，将栈顶元素即上一层字符串添加到当前字符串首端，遇到字符就添加到当前字符串后边。

#### c. 解题代码

```java
class Solution {
    public String reverseParentheses(String s) {
        Deque<String> stack = new LinkedList<String>();
        StringBuffer sb = new StringBuffer();
        for(int i = 0; i < s.length(); i++){
            char ch = s.charAt(i);
            if(ch == '('){
                stack.push(sb.toString());
                sb.setLength(0);
            }else if(ch == ')'){
                sb.reverse();
                sb.insert(0, stack.pop());
            }else{
                sb.append(ch);
            }
        }
        return sb.toString();
    }
}
```

#### d. 其他解法摘录

![image-20210530112746581](https://i.loli.net/2021/05/30/ghaPSj2lXkzROvr.png)

```java
class Solution {
    public String reverseParentheses(String s) {
        int n = s.length();
        int[] pair = new int[n];
        Deque<Integer> stack = new LinkedList<Integer>();
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else if (s.charAt(i) == ')') {
                int j = stack.pop();
                pair[i] = j;
                pair[j] = i;
            }
        }

        StringBuffer sb = new StringBuffer();
        int index = 0, step = 1;
        while (index < n) {
            if (s.charAt(index) == '(' || s.charAt(index) == ')') {
                index = pair[index];
                step = -step;
            } else {
                sb.append(s.charAt(index));
            }
            index += step;
        }
        return sb.toString();
    }
}
```

------

### 第5题 [汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

难度：简单

#### a. 原题陈述

两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

#### b. 解题思路

![image-20210530113409964](https://i.loli.net/2021/05/30/WRvuGga5VsYE6zN.png)

#### c. 解题代码

```java
利用内置函数
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
异或结果每次看最后一位，然后右移一位。
class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int result = 0;
        while(xor > 0){
            result += xor & 1;
            xor = xor >> 1;
        }
        return result;
    }
}
3.
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;
            ret++;
        }
        return ret;
    }
}
```

#### d. 其他解法摘录

```java

```

------

### 第6题 [汉明距离总和](https://leetcode-cn.com/problems/total-hamming-distance/)

难度：中等

方法：递归

#### a. 原题陈述

两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间汉明距离的总和。

#### b. 解题思路

逐位统计

#### c. 解题代码

```java
暴力
class Solution {
    public int totalHammingDistance(int[] nums) {
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            for(int j = i+1; j < nums.length; j++){
                count += Integer.bitCount(nums[i] ^ nums[j]);
            }
        }
        return count;
    }
}
逐位统计
class Solution {
    public int totalHammingDistance(int[] nums) {
        int count = 0;
        for(int i = 0; i < 30; i++){
            int c = 0;
            for(int num : nums){
                c += (num >> i) & 1;
            }
            count += c * (nums.length - c);
        }
        return count;
    }
}
```

#### d. 其他解法摘录

```java

```

------

### 第7题 [元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

难度：困难

方法：遍历二叉树

#### a. 原题陈述

![image-20210530160028509](https://i.loli.net/2021/05/30/MuvnFERHDoOi7tg.png)

#### b. 解题思路

![image-20210530160207743](https://i.loli.net/2021/05/30/ovF9lJ6aBV1bfcK.png)

#### c. 解题代码

```java
前缀和加哈希表
这种哈希表的查找只用循环一层
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int ans = 0;
        int m = matrix.length, n = matrix[0].length;
        for(int i = 0; i < m; i++){
            int sum[] = new int[n];
            for(int j = i; j < m; j++){
                for(int c = 0; c < n; c++){
                    sum[c] += matrix[j][c];
                }
                ans += subarraySum(sum, target);
            }
        }
        return ans;
    }

    public int subarraySum(int[] nums, int k){
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(0, 1);
        int count = 0, pre = 0;
        for(int x : nums){
            pre += x;
            if(map.containsKey(pre - k)){
                count += map.get(pre - k);
            }
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

#### d. 其他解法摘录

```java
二维前缀和加哈希
class Solution {
    public int numSubmatrixSumTarget(int[][] mat, int t) {
        int n = mat.length, m = mat[0].length;
        int[][] sum = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }
        int ans = 0;
        for (int top = 1; top <= n; top++) {
            for (int bot = top; bot <= n; bot++) {
                int cur = 0;
                Map<Integer, Integer> map = new HashMap<>();
                for (int r = 1; r <= m; r++) {
                    cur = sum[bot][r] - sum[top - 1][r];
                    if (cur == t) ans++;
                    if (map.containsKey(cur - t)) ans += map.get(cur - t);
                    map.put(cur, map.getOrDefault(cur, 0) + 1);
                }
            }
        }
        return ans;
    }
}
```

------

### 

### ### 